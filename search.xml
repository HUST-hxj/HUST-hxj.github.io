<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>可持久化并查集模板（带路径压缩、按秩合并优化）</title>
      <link href="/2021/11/06/persistent-union-find-set/"/>
      <url>/2021/11/06/persistent-union-find-set/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/posts/icpc/banner.png" alt="banner"></p><p>最近在备战 ACM-ICPC 亚洲区域赛沈阳站，写点板子供届时使用。</p><h2 id="模板例题"><a href="#模板例题" class="headerlink" title="模板例题"></a>模板例题</h2><p><a href="https://www.luogu.com.cn/problem/P3402">Luogu P3402 可持久化并查集</a></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>, M = <span class="number">2e5</span>, Log4N = <span class="number">19</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val, rank, lchild, rchild;</span><br><span class="line">&#125; tree[<span class="number">4</span> * N + M * Log4N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> init[N + <span class="number">1</span>], root[M + <span class="number">1</span>], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = ++tot;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tree[now].val = init[l];</span><br><span class="line">        tree[now].rank = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    tree[now].lchild = <span class="built_in">build</span>(l, mid);</span><br><span class="line">    tree[now].rchild = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> target, <span class="keyword">int</span> newroot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = ++tot;</span><br><span class="line">    tree[now] = tree[x];</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tree[now].val = newroot;</span><br><span class="line">        tree[newroot].rank = std::<span class="built_in">max</span>(tree[newroot].rank, tree[now].rank + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (target &lt;= mid)</span><br><span class="line">        tree[now].lchild = <span class="built_in">update</span>(tree[x].lchild, l, mid, target, newroot);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tree[now].rchild = <span class="built_in">update</span>(tree[x].rchild, mid + <span class="number">1</span>, r, target, newroot);</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> tree[x].val;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (target &lt;= mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(tree[x].lchild, l, mid, target);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(tree[x].rchild, mid + <span class="number">1</span>, r, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="built_in">query</span>(x, l, r, target);</span><br><span class="line">    <span class="keyword">if</span> (ans == target) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">getroot</span>(x, l, r, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        init[i] = i;</span><br><span class="line">    root[<span class="number">0</span>] = <span class="built_in">build</span>(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">int</span> op, a, b, k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">int</span> root_a = <span class="built_in">getroot</span>(root[i - <span class="number">1</span>], <span class="number">1</span>, n, a);</span><br><span class="line">            <span class="keyword">int</span> root_b = <span class="built_in">getroot</span>(root[i - <span class="number">1</span>], <span class="number">1</span>, n, b);</span><br><span class="line">            <span class="keyword">if</span> (tree[root_a].rank &lt; tree[root_b].rank)</span><br><span class="line">                root[i] = <span class="built_in">update</span>(root[i - <span class="number">1</span>], <span class="number">1</span>, n, root_a, root_b);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                root[i] = <span class="built_in">update</span>(root[i - <span class="number">1</span>], <span class="number">1</span>, n, root_b, root_a);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">            root[i] = root[k];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            root[i] = root[i - <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">getroot</span>(root[i], <span class="number">1</span>, n, a) == <span class="built_in">getroot</span>(root[i], <span class="number">1</span>, n, b));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> OI/ACM </tag>
            
            <tag> 并查集 </tag>
            
            <tag> 主席树 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可持久化线段树（主席树）模板</title>
      <link href="/2021/11/05/persistent-segment-tree/"/>
      <url>/2021/11/05/persistent-segment-tree/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/posts/icpc/banner.png" alt="banner"></p><p>最近在备战 ACM-ICPC 亚洲区域赛沈阳站，写点板子供届时使用。</p><h1 id="单点修改单点查询模板"><a href="#单点修改单点查询模板" class="headerlink" title="单点修改单点查询模板"></a>单点修改单点查询模板</h1><h2 id="模板例题"><a href="#模板例题" class="headerlink" title="模板例题"></a>模板例题</h2><p><a href="https://www.luogu.com.cn/problem/P3919">Luogu P3919【模板】可持久化线段树 1（可持久化数组）</a></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>, M = <span class="number">1e6</span>, Log4N = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val, lchild, rchild;</span><br><span class="line">&#125; tree[<span class="number">4</span> * N + M * Log4N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N + <span class="number">1</span>], root[M + <span class="number">1</span>], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = ++tot;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tree[now].val = a[l];</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    tree[now].lchild = <span class="built_in">build</span>(l, mid);</span><br><span class="line">    tree[now].rchild = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> target, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = ++tot;</span><br><span class="line">    tree[now] = tree[x];</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tree[now].val = val;</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (target &lt;= mid)</span><br><span class="line">        tree[now].lchild = <span class="built_in">update</span>(tree[x].lchild, l, mid, target, val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tree[now].rchild = <span class="built_in">update</span>(tree[x].rchild, mid + <span class="number">1</span>, r, target, val);</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> tree[x].val;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (target &lt;= mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(tree[x].lchild, l, mid, target);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(tree[x].rchild, mid + <span class="number">1</span>, r, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    root[<span class="number">0</span>] = <span class="built_in">build</span>(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ver, op, target, val;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;ver, &amp;op, &amp;target);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;val);</span><br><span class="line">            root[i] = <span class="built_in">update</span>(root[ver], <span class="number">1</span>, n, target, val); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root[i] = ++tot;</span><br><span class="line">            tree[root[i]] = tree[root[ver]];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(root[i], <span class="number">1</span>, n, target));</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单点修改区间查询模板"><a href="#单点修改区间查询模板" class="headerlink" title="单点修改区间查询模板"></a>单点修改区间查询模板</h1><h2 id="模板例题-1"><a href="#模板例题-1" class="headerlink" title="模板例题"></a>模板例题</h2><p><a href="https://www.luogu.com.cn/problem/P3834">Luogu P3834【模板】可持久化线段树 2</a></p><h2 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>, Log4N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val, lchild, rchild;</span><br><span class="line">&#125; tree[<span class="number">4</span> * N + N * Log4N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">item</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> pos, val;</span><br><span class="line">&#125; a[N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root[N + <span class="number">1</span>], val_unique[N + <span class="number">1</span>], tot, cnt_unique;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = ++tot;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tree[now].val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    tree[now].lchild = <span class="built_in">build</span>(l, mid);</span><br><span class="line">    tree[now].rchild = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = ++tot;</span><br><span class="line">    tree[now] = tree[x];</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= target &amp;&amp; target &lt;= r) &#123;</span><br><span class="line">        tree[now].val++;</span><br><span class="line">        <span class="keyword">if</span> (l == r)</span><br><span class="line">            <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (target &lt;= mid)</span><br><span class="line">        tree[now].lchild = <span class="built_in">update</span>(tree[x].lchild, l, mid, target);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tree[now].rchild = <span class="built_in">update</span>(tree[x].rchild, mid + <span class="number">1</span>, r, target);</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> st, <span class="keyword">int</span> ed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (st &lt;= l &amp;&amp; r &lt;= ed) <span class="keyword">return</span> tree[x].val;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= st) ans += <span class="built_in">query</span>(tree[x].lchild, l, mid, st, ed);</span><br><span class="line">    <span class="keyword">if</span> (mid + <span class="number">1</span> &lt;= ed) ans += <span class="built_in">query</span>(tree[x].rchild, mid + <span class="number">1</span>, r, st, ed);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        a[i].pos = i;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i].val);</span><br><span class="line">    &#125;       </span><br><span class="line">    root[<span class="number">0</span>] = <span class="built_in">build</span>(<span class="number">1</span>, n);</span><br><span class="line">    std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, [](item x, item y)&#123;<span class="keyword">return</span> x.val &lt; y.val;&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span> || a[i].val != a[i - <span class="number">1</span>].val) &#123;</span><br><span class="line">            ++cnt_unique;</span><br><span class="line">            val_unique[cnt_unique] = a[i].val;</span><br><span class="line">            root[cnt_unique] = <span class="built_in">update</span>(root[cnt_unique - <span class="number">1</span>], <span class="number">1</span>, n, a[i].pos);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root[cnt_unique] = <span class="built_in">update</span>(root[cnt_unique], <span class="number">1</span>, n, a[i].pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;k);</span><br><span class="line">        <span class="keyword">int</span> st = <span class="number">1</span>, ed = cnt_unique + <span class="number">1</span>, ans = <span class="number">0x7fffffff</span>;        </span><br><span class="line">        <span class="keyword">while</span> (st &lt; ed) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = st + ed &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> result = <span class="built_in">query</span>(root[mid], <span class="number">1</span>, n, l, r);</span><br><span class="line">            <span class="keyword">if</span> (result &gt;= k) &#123;</span><br><span class="line">                ans = std::<span class="built_in">min</span>(ans, val_unique[mid]);</span><br><span class="line">                ed = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> OI/ACM </tag>
            
            <tag> 主席树 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HoneyTuner 一个简洁易用的音频处理工具箱</title>
      <link href="/2021/09/17/introducing-honeytuner/"/>
      <url>/2021/09/17/introducing-honeytuner/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/posts/introducing-honeytuner/banner.png" alt="banner"></p><h1 id="产品介绍"><a href="#产品介绍" class="headerlink" title="产品介绍"></a>产品介绍</h1><p>HoneyTuner 是一个简洁易用的音频处理工具箱，由 Honeta 于 2020 年 10 月 18 日启动开发，初版完工于 2021 年 1 月 5 日。本软件使用了 C / C++ / HTML / CSS / Node.js 等语言并基于 <a href="https://www.electronjs.org/">Electron 框架</a>，支持对 MP3 格式音频文件进行一系列修改操作。目前已经支持的操作有：</p><ul><li>将 MP3 音频文件解码为 WAV 波形音频文件（<a href="https://github.com/mackron/dr_libs">mackron/dr_libs</a>）</li><li>增大或减小音频任意片段的音量</li><li>倒置音频的任意片段</li><li>删除音频的任意片段</li><li>在一个音频的任意位置拼接入另一个音频的任意片段</li><li>在一个音频的任意位置叠加入另一个音频的任意片段</li><li>在上述两个功能的两个操作音频采样率不同时进行采样率同化</li><li>去除音频任意片段的任意声道</li><li>实现音频任意片段的变调加速与减速，以及不变调减速</li><li>为音频任意片段添加任意幅度的混响效果</li><li>将音频任意片段的音调升高任意幅度</li><li>将音频任意片段复制到该音频的其它位置</li><li>将音频任意片段移动到该音频的其它位置</li><li>撤销之前作出的修改</li><li>调用系统播放器试听音频的当前修改版本</li><li>将 WAV 波形音频文件编码为 MP3 音频文件（<a href="https://github.com/mackron/dr_libs">mackron/dr_libs</a>）</li></ul><p>这些功能的使用方式，在软件对应功能界面有详尽的说明。更多功能与特性正在到来的路上，敬请期待。</p><h1 id="产品界面"><a href="#产品界面" class="headerlink" title="产品界面"></a>产品界面</h1><p><img src="/images/posts/introducing-honeytuner/interface.png" alt="HoneyTuner 首页"><br><img src="/images/posts/introducing-honeytuner/decoder.png" alt="HoneyTuner 音频解码"><br><img src="/images/posts/introducing-honeytuner/merge.png" alt="HoneyTuner 片段拼接"><br><img src="/images/posts/introducing-honeytuner/discard.png" alt="HoneyTuner 撤销修改"></p><h1 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a>下载链接</h1><p>最新版本：1.0.2</p><ul><li><a href="https://husthxj.top/files/honeytuner-win32-x64-1.0.2.zip">直接下载</a></li><li><a href="https://pan.baidu.com/s/1SvGv3JoYG2ZOTngY289OPA">百度网盘</a> （提取码: x6yf）</li><li><a href="https://github.com/HUST-hxj/HoneyTuner/releases/download/1.0.2/honeytuner-win32-x64-1.0.2.zip">Github</a></li></ul><h1 id="版本日志"><a href="#版本日志" class="headerlink" title="版本日志"></a>版本日志</h1><ul><li><p>2021.09.17 Ver 1.0.2 <strong>(Latest)</strong></p><ul><li>首个正式发布版本</li><li>添加在 Windows 系统下使用的源码自动编译脚本（需安装 Node.js 和 GCC）</li></ul></li><li><p>2021.01.11 Ver 1.0.1</p><ul><li>添加窗口大小自定义</li><li>对部分细节进行优化</li></ul></li><li><p>2021.01.05 Ver 1.0.0</p><ul><li>HoneyTuner 的第一个版本</li></ul></li></ul><h1 id="开源地址"><a href="#开源地址" class="headerlink" title="开源地址"></a>开源地址</h1><ul><li><a href="https://github.com/Honeta/HoneyTuner">Github</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 作品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Electron </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P3931 一道难题 Tree 题解</title>
      <link href="/2019/10/10/luogu-p3931/"/>
      <url>/2019/10/10/luogu-p3931/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/posts/luogu/banner.png" alt="banner"></p><h2 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h2><p><a href="https://www.luogu.com.cn/problem/P3931">https://www.luogu.com.cn/problem/P3931</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>根据题意，本题与最小割问题极为相似，根据最大流最小割定理，本题可转化为求网络最大流。</p><span id="more"></span><p>还未学习该知识的，请先学习，然后建议先写模板题练习一下。</p><p>首先，提醒一个雷区！题目给的是一个无向图，故我们需要先从树根开始对这个无向图进行dfs预处理，把无向边转换成有向边。（WA 20分的绝大多数都忽略了这一点，包括我）</p><p>然后，一个网络流图不仅要有源点（即树的根节点），还要有汇点。我们假设n+1即为汇点，让所有的叶子节点都伸出一条指向n+1的有向边（这个可以在dfs预处理时顺便处理一下，而且要记得建反向边）。</p><p>题目要求任何叶子节点都和根节点不连通，而这个条件恰恰和汇点和源点不连通是等价的（因为所有叶子节点都和汇点连通，故但凡有任何一个叶子节点和根节点连通，汇点和源点都是连通的）。</p><p>至此，我们已经完成了构造，接下来问题就只剩下求网络流图的最大流了。这里有多种算法可以选择，我使用的是dinic算法，具体实现不再赘述。在存图时我采取的是vector存图，下面的代码供参考。</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I 0x3f3f3f3f<span class="comment">//无穷大</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">road</span>&#123;</span><span class="keyword">int</span> to,w;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> to,w;&#125;e[N&lt;&lt;<span class="number">2</span>];<span class="comment">//存储边的信息，考虑到双向建边（包括叶子节点与汇点）的问题，保险起见开四倍数组</span></span><br><span class="line">vector&lt;road&gt; g[N];<span class="comment">//存初始的无向图</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v[N];<span class="comment">//存转化之后的有向图</span></span><br><span class="line"><span class="keyword">int</span> n,s,t,t1,t2,t3,cnt,ans,d[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(g[x].<span class="built_in">size</span>()==<span class="number">1</span>&amp;&amp;g[x][<span class="number">0</span>].to==fa)<span class="comment">//判叶子节点，和汇点建边</span></span><br><span class="line">    &#123;</span><br><span class="line">      v[x].<span class="built_in">push_back</span>(cnt);</span><br><span class="line">      e[cnt].to=t;</span><br><span class="line">      e[cnt++].w=I;</span><br><span class="line">      v[t].<span class="built_in">push_back</span>(cnt);<span class="comment">//建反向边</span></span><br><span class="line">      e[cnt].to=x;</span><br><span class="line">      e[cnt++].w=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g[x].<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> to=g[x][i].to,w=g[x][i].w;</span><br><span class="line">      <span class="keyword">if</span>(to==fa)<span class="keyword">continue</span>;</span><br><span class="line">      v[x].<span class="built_in">push_back</span>(cnt);</span><br><span class="line">      e[cnt].to=to;</span><br><span class="line">      e[cnt++].w=w;</span><br><span class="line">      v[to].<span class="built_in">push_back</span>(cnt);<span class="comment">//建反向边</span></span><br><span class="line">      e[cnt].to=x;</span><br><span class="line">      e[cnt++].w=<span class="number">0</span>;</span><br><span class="line">      <span class="built_in">pre</span>(to,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">  d[s]=<span class="number">1</span>;</span><br><span class="line">  q.<span class="built_in">push</span>(s);</span><br><span class="line">  <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> now=q.<span class="built_in">front</span>();</span><br><span class="line">      q.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v[now].<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> temp=v[now][i];</span><br><span class="line">      <span class="keyword">int</span> to=e[temp].to,w=e[temp].w;</span><br><span class="line">      <span class="keyword">if</span>(!d[to]&amp;&amp;w)</span><br><span class="line">        &#123;</span><br><span class="line">          d[to]=d[now]+<span class="number">1</span>;</span><br><span class="line">          q.<span class="built_in">push</span>(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> d[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> minn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(now==t)<span class="keyword">return</span> minn;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v[now].<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> temp=v[now][i];</span><br><span class="line">      <span class="keyword">int</span> to=e[temp].to,w=e[temp].w;</span><br><span class="line">      <span class="keyword">if</span>(d[to]==d[now]+<span class="number">1</span>&amp;&amp;w)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> res=<span class="built_in">dfs</span>(to,<span class="built_in">min</span>(minn,w));</span><br><span class="line">      <span class="keyword">if</span>(res)</span><br><span class="line">        &#123;</span><br><span class="line">          e[temp].w-=res;</span><br><span class="line">          e[temp^<span class="number">1</span>].w+=res;</span><br><span class="line">          <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;s);</span><br><span class="line">  t=n+<span class="number">1</span>;<span class="comment">//设置汇点</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;t1,&amp;t2,&amp;t3);</span><br><span class="line">      g[t1].<span class="built_in">push_back</span>(&#123;t2,t3&#125;);<span class="comment">//存无向图</span></span><br><span class="line">      g[t2].<span class="built_in">push_back</span>(&#123;t1,t3&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">pre</span>(s,s);<span class="comment">//预处理，无向图转有向图</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">bfs</span>())<span class="comment">//dinic算法求最大流</span></span><br><span class="line">    ans+=<span class="built_in">dfs</span>(s,I);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> OI/ACM </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 广度优先搜索 </tag>
            
            <tag> 最大流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P3014 牛线Cow Line 题解</title>
      <link href="/2019/10/09/luogu-p3014/"/>
      <url>/2019/10/09/luogu-p3014/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/posts/luogu/banner.png" alt="banner"></p><h2 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h2><p><a href="https://www.luogu.com.cn/problem/P3014">https://www.luogu.com.cn/problem/P3014</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>康托展开（使用树状数组优化）与逆康托展开。</p><span id="more"></span><p>在康托展开时，需要计算每一位数字在它和它以后的所有数字中是第几大的数，在这里我使用了树状数组对算法的时间复杂度进行了优化。</p><p>我们设add(x,y)是将x加上y，ask(x)是查询x的前缀和。在预处理时，我们对从1到n的每一个i都分别add(i,1),假设我们当前算到了第i位数a[i]，首先我们add(a[i],-1),这个操作就相当于把a[i]划掉，而在第i位之前出现过的数都已经被我们提前划掉了。那么ask(a[i])即为在第i位之后出现的比a[i]小的数的总个数（即：还未被划掉的比a[i]小的数的总个数）。这样，我们就巧妙地利用了树状数组的性质对康托展开进行了优化。在数据较大时，这种优化作用是极为显著的。</p><p>最后提醒一下：一定要开long long！</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll n,k,t2,ans,fact[<span class="number">21</span>],tree[<span class="number">21</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">21</span>];</span><br><span class="line"><span class="keyword">char</span> t1;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;x&lt;=n;x+=x&amp;-x)tree[x]+=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ll res=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;x;x-=x&amp;-x)res+=tree[x];</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">  fact[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;n;i++)fact[i]=fact[i<span class="number">-1</span>]*i;<span class="comment">//递推求阶乘</span></span><br><span class="line">  <span class="keyword">while</span>(k--)</span><br><span class="line">    &#123;</span><br><span class="line">      cin&gt;&gt;t1;</span><br><span class="line">      <span class="built_in">memset</span>(tree,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(tree));</span><br><span class="line">      <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">      <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">add</span>(i,<span class="number">1</span>);<span class="comment">//预处理树状数组</span></span><br><span class="line">      <span class="built_in"><span class="keyword">switch</span></span>(t1)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>:<span class="comment">//康托展开（树状数组优化）</span></span><br><span class="line">      ans=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;t2);</span><br><span class="line">          <span class="built_in">add</span>(t2,<span class="number">-1</span>);<span class="comment">//划掉这个数</span></span><br><span class="line">          ans+=<span class="built_in">ask</span>(t2)*fact[n-i];<span class="comment">//运用树状数组求这位数字在它和它以后的所有数字中是第几大的数</span></span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans+<span class="number">1</span>);<span class="comment">//记得求出来的结果要加1</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;P&#x27;</span>:<span class="comment">//逆康托展开</span></span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;t2);</span><br><span class="line">      t2--;</span><br><span class="line">      <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">          ll temp=t2/fact[n-i];</span><br><span class="line">          <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span>(vis[j])<span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">if</span>(!temp)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,j);</span><br><span class="line">              vis[j]=<span class="number">1</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          temp--;</span><br><span class="line">        &#125;</span><br><span class="line">          t2%=fact[n-i];</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> OI/ACM </tag>
            
            <tag> 康托展开 </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P1280 尼克的任务 题解</title>
      <link href="/2019/10/05/luogu-p1280/"/>
      <url>/2019/10/05/luogu-p1280/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/posts/luogu/banner.png" alt="banner"></p><h2 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h2><p><a href="https://www.luogu.com.cn/problem/P1280">https://www.luogu.com.cn/problem/P1280</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>动态规划，具体步骤如下。</p><span id="more"></span><ul><li><p>预处理阶段<br>设置两个bool数组begin、end，begin数组记录每个时间点有无任务开始，end数组记录每个时间点有无任务结束。每次输入一个任务的起止时间后，更新两个bool数组并建立一条从终止时间到起止时间的有向边，用vector实现的二维数组存储。</p></li><li><p>DP阶段<br>从后往前进行一遍扫描。设置数组f，f[i]记录从时间点i到工作日结束之间最长的空暇时间（即：时间点i的“逆推最大空暇时间”）。</p></li></ul><p>扫描到有任务结束的时间点时，以为此时任务刚结束，从下一分钟才会进入空暇状态，故我们用当前时间下一分钟的“逆推最大空暇时间”分别对【当前时间结束的所有任务】的起始时间的“逆推最大空暇时间”进行比较，若更大则替换之。这一步把所有有任务开始的时间点的“逆推最大空暇时间”已经更新为最优解。</p><p>同时，若没有任务在当前时间开始，则下一分钟的“逆推最大空暇时间”加一之后即为当前时间的“逆推最大空暇时间”。</p><p>一遍扫描过后，f[1]即为从工作日开始到工作日结束的“逆推最大空暇时间”，直接输出即可。</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,k,t,p,now,f[<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">bool</span> begin[<span class="number">10001</span>],end[<span class="number">10001</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v[<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&gt;y?x:y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)<span class="comment">//预处理阶段</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;p,&amp;t);</span><br><span class="line">      begin[p]=<span class="number">1</span>;<span class="comment">//做标记</span></span><br><span class="line">      end[p+t<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">      v[p+t<span class="number">-1</span>].<span class="built_in">push_back</span>(p);<span class="comment">//建边</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)<span class="comment">//DP阶段</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(end[i])</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;v[i].<span class="built_in">size</span>();k++)</span><br><span class="line">      f[v[i][k]]=<span class="built_in">max</span>(f[v[i][k]],f[i+<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">if</span>(!begin[i])f[i]=f[i+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> OI/ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P1064 金明的预算方案 题解</title>
      <link href="/2019/10/05/luogu-p1064/"/>
      <url>/2019/10/05/luogu-p1064/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/posts/luogu/banner.png" alt="banner"></p><h2 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h2><p><a href="https://www.luogu.com.cn/problem/P1064">https://www.luogu.com.cn/problem/P1064</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>根据题意我们可以得知，只选主件、只选主件和第一个附件、只选主件和第二个附件、主件和两个附件都选这四种情况是互斥的，只能且必须任选其一，符合分组背包类似于“每组物品中只能选一个”的性质。由此可知，本题可以设法使用分组背包来做。我们根据题目特性，巧用预处理把问题转化为分组背包问题。</p><span id="more"></span><p>首先进行预处理，我们用一个结构体来存储物品的信息，把所有物品依照主附件关系分为若干组用vector容器v构建二维数组来存储。</p><p>在读入数据时，如果第i件物品是主件，那我们就把第i件物品的价格（DP时用到）和价格与重要度的乘积（更新答案时用到，以下都称“实际权重”）push_back到v[i]中；如果第i件物品是第j件物品的附件，那就把物品j按照如下规定的思路push_back到v[j]，v[i]留空即可。</p><p>根据四种互斥情况，我们规定每组物品：</p><ul><li>第一个物品的价格和实际权重等于主件；</li><li>第二个物品的价格和实际权重等于主件+第一个附件；</li><li>第三个物品的价格和实际权重等于主件+第二个附件；</li><li>第四个物品的价格和实际权重等于主件+第一个附件+第二个附件；</li></ul><p>又因为主件=第一个物品，主件+第一个附件=第二个物品，故上述规定可以表示为：</p><ul><li>第一个物品的价格和实际权重等于主件；</li><li>第二个物品的价格和实际权重等于第一个物品+第一个附件；</li><li>第三个物品的价格和实际权重等于第一个物品+第二个附件；</li><li>第四个物品的价格和实际权重等于第二个物品+第二个附件；</li></ul><p>上述规定可以用一个for循环进行递推计算，每次加入新附件时在遍历已有该附件对应主件和该主件其它附件的同时进行累加，将累加后的结果push_back到末端即可。（具体请参照代码）</p><p>至此，预处理结束，设m件物品中有a件主件和m-a件附件，则这些物品已经被分为a组，每组物品以主件开头，最多4件物品（根据题目数据，附件是一定出现在主件之后的）。</p><p>问题已经彻底转化成了一个分组背包问题，直接套用分组背包DP的模板求解即可。</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">good</span>&#123;</span><span class="keyword">int</span> w,t;&#125;;</span><br><span class="line">vector&lt;good&gt; v[<span class="number">61</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,a,b,c,f[<span class="number">32001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&gt;y?x:y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">      <span class="keyword">int</span> temp=v[c].<span class="built_in">size</span>();<span class="comment">//提前记录当前主件和该主件已出现的附件的总数，避免后面出现死循环</span></span><br><span class="line">      <span class="keyword">if</span>(!c)v[i].<span class="built_in">push_back</span>(&#123;a,a*b&#125;);<span class="comment">//处理主件</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;temp;k++)</span><br><span class="line">         v[c].<span class="built_in">push_back</span>(&#123;a+v[c][k].w,a*b+v[c][k].t&#125;);<span class="comment">//依据题解中规则处理附件</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//一维分组背包模板</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=n;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;v[i].<span class="built_in">size</span>();k++)</span><br><span class="line">    &#123;</span><br><span class="line">      good now=v[i][k];</span><br><span class="line">      <span class="keyword">if</span>(j&gt;=now.w)f[j]=<span class="built_in">max</span>(f[j],f[j-now.w]+now.t);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[n]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> OI/ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P2296 寻找道路 题解</title>
      <link href="/2019/09/26/luogu-p2296/"/>
      <url>/2019/09/26/luogu-p2296/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/posts/luogu/banner.png" alt="banner"></p><h2 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h2><p><a href="https://www.luogu.com.cn/problem/P2296">https://www.luogu.com.cn/problem/P2296</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>读入图时建立正向边和反向边，两次DFS标记所有合法的点，再进行一遍BFS求最短路径。</p><span id="more"></span><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,t1,t2,s,t,d[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N],go1[N],go2[N],go[N],inq[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; gt[N],g[N];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vis[x]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;gt[x].<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> to=gt[x][i];</span><br><span class="line">      <span class="keyword">if</span>(go1[x])go1[to]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(vis[to])<span class="keyword">continue</span>;</span><br><span class="line">      <span class="built_in">dfs1</span>(to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vis[x]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g[x].<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> to=g[x][i];</span><br><span class="line">      <span class="keyword">if</span>(go2[x])go2[to]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(vis[to])<span class="keyword">continue</span>;</span><br><span class="line">      <span class="built_in">dfs2</span>(to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;t1,&amp;t2);</span><br><span class="line">      <span class="keyword">if</span>(t1==t2)<span class="keyword">continue</span>;</span><br><span class="line">      gt[t2].<span class="built_in">push_back</span>(t1);<span class="comment">//反向建图</span></span><br><span class="line">      g[t1].<span class="built_in">push_back</span>(t2);<span class="comment">//正向建图</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;s,&amp;t);</span><br><span class="line">  go1[t]=go2[t]=<span class="number">1</span>;</span><br><span class="line">  d[t]=<span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">dfs1</span>(t);<span class="comment">//dfs反向图，标记和终点反向联通的点</span></span><br><span class="line">  <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">  <span class="built_in">dfs2</span>(t);<span class="comment">//dfs正向图，标记和终点正向联通的点</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//标记所有合法点</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(!go1[i]&amp;&amp;!go2[i])<span class="keyword">continue</span>;</span><br><span class="line">      go[i]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;g[i].<span class="built_in">size</span>();j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> to=g[i][j];</span><br><span class="line">      <span class="keyword">if</span>(!go1[to]&amp;&amp;!go2[to])</span><br><span class="line">        &#123;</span><br><span class="line">          go[i]=<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  q.<span class="built_in">push</span>(s);</span><br><span class="line">  inq[s]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())<span class="comment">//bfs正向图，得最短路径</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> now=q.<span class="built_in">front</span>();</span><br><span class="line">      q.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g[now].<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> to=g[now][i];</span><br><span class="line">      <span class="keyword">if</span>(inq[to]||!go[to])<span class="keyword">continue</span>;</span><br><span class="line">      q.<span class="built_in">push</span>(to);</span><br><span class="line">      inq[to]=<span class="number">1</span>;</span><br><span class="line">      d[to]=d[now]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,d[t]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> OI/ACM </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 广度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P1010 幂次方 题解</title>
      <link href="/2019/05/08/luogu-p1010/"/>
      <url>/2019/05/08/luogu-p1010/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/posts/luogu/banner.png" alt="banner"></p><h2 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h2><p><a href="https://www.luogu.com.cn/problem/P1010">https://www.luogu.com.cn/problem/P1010</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>本蒟蒻来发一波题解，没多少技巧，就是打表。</p><span id="more"></span><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> for(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,mega[<span class="number">111</span>];<span class="comment">//mega数组存储预处理的2的1到14次方（2^15&gt;20000，所以之后的枚举只需到14即可）</span></span><br><span class="line">string open[<span class="number">15</span>];</span><br><span class="line"><span class="keyword">bool</span> odd;<span class="comment">//数的奇偶</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">even</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">    odd=<span class="number">1</span>;</span><br><span class="line">    n-=<span class="number">1</span>;<span class="comment">//如果是奇数就直接先-1变成偶数，最后再把1补上</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">even</span>();<span class="comment">//判断奇偶</span></span><br><span class="line">    <span class="keyword">for</span>(i,<span class="number">1</span>,<span class="number">14</span>)mega[i]=<span class="built_in">pow</span>(<span class="number">2</span>,i);<span class="comment">//预处理并存储2的1~14次方</span></span><br><span class="line"><span class="comment">//前方高能，预处理并存储1~14拆分后的字符串，后面用</span></span><br><span class="line">    open[<span class="number">1</span>]=<span class="string">&quot;2(0)&quot;</span>;open[<span class="number">2</span>]=<span class="string">&quot;2&quot;</span>;open[<span class="number">3</span>]=<span class="string">&quot;2+2(0)&quot;</span>;open[<span class="number">4</span>]=<span class="string">&quot;2(2)&quot;</span>;</span><br><span class="line">    open[<span class="number">5</span>]=<span class="string">&quot;2(2)+2(0)&quot;</span>;open[<span class="number">6</span>]=<span class="string">&quot;2(2)+2&quot;</span>;open[<span class="number">7</span>]=<span class="string">&quot;2(2)+2+2(0)&quot;</span>;</span><br><span class="line">    open[<span class="number">8</span>]=<span class="string">&quot;2(2+2(0))&quot;</span>;open[<span class="number">9</span>]=<span class="string">&quot;2(2+2(0))+2(0)&quot;</span>;open[<span class="number">10</span>]=<span class="string">&quot;2(2+2(0))+2&quot;</span>;</span><br><span class="line">    open[<span class="number">11</span>]=<span class="string">&quot;2(2+2(0))+2+2(0)&quot;</span>;open[<span class="number">12</span>]=<span class="string">&quot;2(2+2(0))+2(2)&quot;</span>;</span><br><span class="line">    open[<span class="number">13</span>]=<span class="string">&quot;2(2+2(0))+2(2)+2(0)&quot;</span>;open[<span class="number">14</span>]=<span class="string">&quot;2(2+2(0))+2(2)+2&quot;</span>;</span><br><span class="line"><span class="comment">//前方高能，逐一枚举，七层循环最多支持拆分成8项（奇数拆分后末尾的2（0）单独特判）</span></span><br><span class="line">    <span class="keyword">for</span>(x,<span class="number">0</span>,<span class="number">14</span>)</span><br><span class="line">    <span class="keyword">for</span>(y,x,<span class="number">14</span>)</span><br><span class="line">    <span class="keyword">for</span>(z,y,<span class="number">14</span>)</span><br><span class="line">    <span class="keyword">for</span>(i,z,<span class="number">14</span>)</span><br><span class="line">    <span class="keyword">for</span>(j,i,<span class="number">14</span>)</span><br><span class="line">    <span class="keyword">for</span>(k,j,<span class="number">14</span>)</span><br><span class="line">    <span class="keyword">for</span>(l,k,<span class="number">14</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mega[i]+mega[j]+mega[k]+mega[l]+mega[x]+mega[y]+mega[z]==n)<span class="comment">//如果满足条件就输出</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l&amp;&amp;l!=<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;2(&quot;</span>&lt;&lt;open[l]&lt;&lt;<span class="string">&#x27;)&#x27;</span>;<span class="comment">//特判，此项是0就不输出，是2的1次方就直接输出2，否则输出2（x），x也要拆，此时数据范围已经缩小到1~14，直接调用open数组然后输出即可</span></span><br><span class="line">            <span class="keyword">if</span>(l==<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;+2&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(k&amp;&amp;k!=<span class="number">1</span>)cout&lt;&lt;<span class="string">&#x27;+&#x27;</span>&lt;&lt;<span class="string">&quot;2(&quot;</span>&lt;&lt;open[k]&lt;&lt;<span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;+2&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(j&amp;&amp;j!=<span class="number">1</span>)cout&lt;&lt;<span class="string">&#x27;+&#x27;</span>&lt;&lt;<span class="string">&quot;2(&quot;</span>&lt;&lt;open[j]&lt;&lt;<span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;+2&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;&amp;i!=<span class="number">1</span>)cout&lt;&lt;<span class="string">&#x27;+&#x27;</span>&lt;&lt;<span class="string">&quot;2(&quot;</span>&lt;&lt;open[i]&lt;&lt;<span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;+2&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(z&amp;&amp;z!=<span class="number">1</span>)cout&lt;&lt;<span class="string">&#x27;+&#x27;</span>&lt;&lt;<span class="string">&quot;2(&quot;</span>&lt;&lt;open[z]&lt;&lt;<span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(z==<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;+2&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(y&amp;&amp;y!=<span class="number">1</span>)cout&lt;&lt;<span class="string">&#x27;+&#x27;</span>&lt;&lt;<span class="string">&quot;2(&quot;</span>&lt;&lt;open[y]&lt;&lt;<span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(y==<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;+2&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(x&amp;&amp;x!=<span class="number">1</span>)cout&lt;&lt;<span class="string">&#x27;+&#x27;</span>&lt;&lt;<span class="string">&quot;2(&quot;</span>&lt;&lt;open[x]&lt;&lt;<span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(x==<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;+2&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(odd)cout&lt;&lt;<span class="string">&quot;+2(0)&quot;</span>;<span class="comment">//奇数的话，把末尾1补上</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//找到一组就直接输出然后return0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 打表 </tag>
            
            <tag> 数论 </tag>
            
            <tag> 洛谷 </tag>
            
            <tag> OI/ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P1603 斯诺登的密码 题解</title>
      <link href="/2019/04/19/luogu-p1603/"/>
      <url>/2019/04/19/luogu-p1603/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/posts/luogu/banner.png" alt="banner"></p><h2 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h2><p><a href="https://www.luogu.com.cn/problem/P1603">https://www.luogu.com.cn/problem/P1603</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题，我的思路有打表的成分，还用了哈希。</p><span id="more"></span><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1111</span>],sx[<span class="number">1111</span>],h[<span class="number">55</span>],cnt,temp,start;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(string x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> b=<span class="number">1111111111</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lens=x.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lens;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans*=b;</span><br><span class="line">        ans+=x[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//打表，存储1~20的哈希值（first、another什么的另外存）</span></span><br><span class="line">    h[<span class="number">1</span>]=<span class="built_in">hash</span>(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">    h[<span class="number">2</span>]=<span class="built_in">hash</span>(<span class="string">&quot;two&quot;</span>);</span><br><span class="line">    h[<span class="number">3</span>]=<span class="built_in">hash</span>(<span class="string">&quot;three&quot;</span>);</span><br><span class="line">    h[<span class="number">4</span>]=<span class="built_in">hash</span>(<span class="string">&quot;four&quot;</span>);</span><br><span class="line">    h[<span class="number">5</span>]=<span class="built_in">hash</span>(<span class="string">&quot;five&quot;</span>);</span><br><span class="line">    h[<span class="number">6</span>]=<span class="built_in">hash</span>(<span class="string">&quot;six&quot;</span>);</span><br><span class="line">    h[<span class="number">7</span>]=<span class="built_in">hash</span>(<span class="string">&quot;seven&quot;</span>);</span><br><span class="line">    h[<span class="number">8</span>]=<span class="built_in">hash</span>(<span class="string">&quot;eight&quot;</span>);</span><br><span class="line">    h[<span class="number">9</span>]=<span class="built_in">hash</span>(<span class="string">&quot;nine&quot;</span>);</span><br><span class="line">    h[<span class="number">10</span>]=<span class="built_in">hash</span>(<span class="string">&quot;ten&quot;</span>);</span><br><span class="line">    h[<span class="number">11</span>]=<span class="built_in">hash</span>(<span class="string">&quot;eleven&quot;</span>);</span><br><span class="line">    h[<span class="number">12</span>]=<span class="built_in">hash</span>(<span class="string">&quot;twelve&quot;</span>);</span><br><span class="line">    h[<span class="number">13</span>]=<span class="built_in">hash</span>(<span class="string">&quot;thirteen&quot;</span>);</span><br><span class="line">    h[<span class="number">14</span>]=<span class="built_in">hash</span>(<span class="string">&quot;fourteen&quot;</span>);</span><br><span class="line">    h[<span class="number">15</span>]=<span class="built_in">hash</span>(<span class="string">&quot;fifteen&quot;</span>);</span><br><span class="line">    h[<span class="number">16</span>]=<span class="built_in">hash</span>(<span class="string">&quot;sixteen&quot;</span>);</span><br><span class="line">    h[<span class="number">17</span>]=<span class="built_in">hash</span>(<span class="string">&quot;seventeen&quot;</span>);</span><br><span class="line">    h[<span class="number">18</span>]=<span class="built_in">hash</span>(<span class="string">&quot;eighteen&quot;</span>);</span><br><span class="line">    h[<span class="number">19</span>]=<span class="built_in">hash</span>(<span class="string">&quot;nineteen&quot;</span>);</span><br><span class="line">    h[<span class="number">20</span>]=<span class="built_in">hash</span>(<span class="string">&quot;twenty&quot;</span>);</span><br><span class="line">    h[<span class="number">21</span>]=<span class="built_in">hash</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    h[<span class="number">22</span>]=<span class="built_in">hash</span>(<span class="string">&quot;both&quot;</span>);</span><br><span class="line">    h[<span class="number">23</span>]=<span class="built_in">hash</span>(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">    h[<span class="number">24</span>]=<span class="built_in">hash</span>(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">    h[<span class="number">25</span>]=<span class="built_in">hash</span>(<span class="string">&quot;third&quot;</span>);</span><br><span class="line">    h[<span class="number">26</span>]=<span class="built_in">hash</span>(<span class="string">&quot;another&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]&lt;<span class="string">&#x27;a&#x27;</span>)s[<span class="number">0</span>]+=<span class="number">32</span>;<span class="comment">//单词首字母统一转换成小写</span></span><br><span class="line">        temp=<span class="built_in">hash</span>(s);<span class="comment">//计算该单词哈希值，之后逐一比对(提前计算好各数字平方%100之后的数)</span></span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">1</span>]||temp==h[<span class="number">21</span>]||temp==h[<span class="number">23</span>]||temp==h[<span class="number">26</span>])a[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">2</span>]||temp==h[<span class="number">22</span>]||temp==h[<span class="number">24</span>])a[i]=<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">3</span>]||temp==h[<span class="number">25</span>])a[i]=<span class="number">9</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">4</span>])a[i]=<span class="number">16</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">5</span>]||temp==h[<span class="number">15</span>])a[i]=<span class="number">25</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">6</span>])a[i]=<span class="number">36</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">7</span>])a[i]=<span class="number">49</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">8</span>])a[i]=<span class="number">64</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">9</span>])a[i]=<span class="number">81</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">10</span>]||temp==h[<span class="number">20</span>])a[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">11</span>])a[i]=<span class="number">21</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">12</span>])a[i]=<span class="number">44</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">13</span>])a[i]=<span class="number">69</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">14</span>])a[i]=<span class="number">96</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">16</span>])a[i]=<span class="number">56</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">17</span>])a[i]=<span class="number">89</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">18</span>])a[i]=<span class="number">24</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">19</span>])a[i]=<span class="number">61</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;s;<span class="comment">//输入末尾的句点，没卵用</span></span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">7</span>);<span class="comment">//将数字从小到大排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sx[++cnt]=a[i]/<span class="number">10</span>;</span><br><span class="line">        sx[++cnt]=a[i]%<span class="number">10</span>;</span><br><span class="line">    &#125;<span class="comment">//此处可能比较笨，是逐位输入到另一个数组</span></span><br><span class="line">    <span class="keyword">while</span>(sx[start]==<span class="number">0</span>&amp;&amp;start&lt;cnt)start++;<span class="comment">//滤掉开头所有0（如果全都是0则保留一个）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=cnt;i++)cout&lt;&lt;sx[i];<span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 打表 </tag>
            
            <tag> 洛谷 </tag>
            
            <tag> OI/ACM </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
