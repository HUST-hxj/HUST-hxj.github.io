<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>两种常见递归模型动态规划典型问题的模板（树形 DP、数位 DP）</title>
      <link href="/2021/11/19/dp-recursive-model/"/>
      <url>/2021/11/19/dp-recursive-model/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/posts/icpc/banner.png" alt="banner"></p><h1 id="树形-DP-典型问题的模板"><a href="#树形-DP-典型问题的模板" class="headerlink" title="树形 DP 典型问题的模板"></a>树形 DP 典型问题的模板</h1><h2 id="模板例题"><a href="#模板例题" class="headerlink" title="模板例题"></a>模板例题</h2><p><a href="https://codeforces.com/gym/101667/attachments/download/6491/problemset-2017.pdf">2017 ACM-ICPC Asia Daejeon Regional - A</a></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, f[N + <span class="number">1</span>][N &lt;&lt; <span class="number">1</span> | <span class="number">1</span>];</span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; g[N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> x : g[now])        </span><br><span class="line">        <span class="keyword">if</span> (x != fa)</span><br><span class="line">            <span class="built_in">dp</span>(x, now);            </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = -n + <span class="number">1</span>; k &lt;= <span class="number">0</span>; k++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : g[now])        </span><br><span class="line">            <span class="keyword">if</span> (x != fa)</span><br><span class="line">                sum += f[x][-k + n];  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : g[now])        </span><br><span class="line">            <span class="keyword">if</span> (x != fa)</span><br><span class="line">                f[now][k + n] = std::<span class="built_in">min</span>(f[now][k + n], sum - f[x][-k + n] + f[x][k - <span class="number">1</span> + n]);</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : g[now])   </span><br><span class="line">            <span class="keyword">if</span> (x != fa)</span><br><span class="line">                sum += f[x][k - <span class="number">1</span> + n];</span><br><span class="line">        f[now][k + n] = std::<span class="built_in">min</span>(f[now][k + n], sum);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = -n; k &lt;= <span class="number">-1</span>; k++) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : g[now])</span><br><span class="line">            <span class="keyword">if</span> (x != fa)</span><br><span class="line">                sum += f[x][-k + n];</span><br><span class="line">        f[now][k + n] = std::<span class="built_in">min</span>(f[now][k + n], sum - k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = -n + <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">        f[now][k + n] = std::<span class="built_in">min</span>(f[now][k + n], f[now][k - <span class="number">1</span> + n]);           </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        std::cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dp</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    std::cout &lt;&lt; f[<span class="number">1</span>][<span class="number">0</span> + n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数位-DP-典型问题的模板"><a href="#数位-DP-典型问题的模板" class="headerlink" title="数位 DP 典型问题的模板"></a>数位 DP 典型问题的模板</h1><h2 id="模板例题-1"><a href="#模板例题-1" class="headerlink" title="模板例题"></a>模板例题</h2><p><a href="https://www.luogu.com.cn/problem/P2602">Luogu P2602 [ZJOI2010]数字计数</a></p><h2 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[N + <span class="number">1</span>], cnt;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> f[N + <span class="number">1</span>][<span class="number">2</span>][N + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">bool</span> limit, <span class="keyword">int</span> sum, <span class="keyword">bool</span> zero, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == cnt + <span class="number">1</span>) <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="keyword">if</span> (f[k][limit][sum][zero] != <span class="number">-1</span>) </span><br><span class="line">        <span class="keyword">return</span> f[k][limit][sum][zero];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (limit &amp;&amp; i &gt; num[k]) <span class="keyword">break</span>;</span><br><span class="line">        ans += <span class="built_in">dp</span>(k + <span class="number">1</span>, limit &amp;&amp; i == num[k], </span><br><span class="line">            sum + (!(zero &amp;&amp; i == <span class="number">0</span>) &amp;&amp; i == target), </span><br><span class="line">            zero &amp;&amp; i == <span class="number">0</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">    f[k][limit][sum][zero] = ans;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">solve</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> x, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x) &#123;</span><br><span class="line">        num[++cnt] = x % <span class="number">10</span>;</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">reverse</span>(num + <span class="number">1</span>, num + cnt + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(f));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dp</span>(<span class="number">1</span>, <span class="literal">true</span>, <span class="number">0</span>, <span class="literal">true</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, <span class="built_in">solve</span>(b, i) - <span class="built_in">solve</span>(a - <span class="number">1</span>, i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OI/ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 树形 DP </tag>
            
            <tag> 数位 DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚树模板</title>
      <link href="/2021/11/17/virtual-tree/"/>
      <url>/2021/11/17/virtual-tree/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/posts/icpc/banner.png" alt="banner"></p><h2 id="模板例题"><a href="#模板例题" class="headerlink" title="模板例题"></a>模板例题</h2><p><a href="https://www.luogu.com.cn/problem/P2495">Luogu P2495 [SDOI2011]消耗战</a></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2.5e5</span>, K = <span class="number">2.5e5</span>, LogN = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> to;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[N + <span class="number">1</span>], dfn_time, fa[N + <span class="number">1</span>][LogN + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> d[N + <span class="number">1</span>], min_w[N + <span class="number">1</span>][LogN + <span class="number">1</span>], a[K], f[N + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> flag[N + <span class="number">1</span>];</span><br><span class="line">std::vector&lt;edge&gt; g[N + <span class="number">1</span>], tree[N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">long</span> <span class="keyword">long</span> now_min, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    d[x] = depth;</span><br><span class="line">    dfn[x] = ++dfn_time;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= d[x]; i++) &#123;</span><br><span class="line">        fa[x][i] = fa[fa[x][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line">        min_w[x][i] = std::<span class="built_in">min</span>(min_w[x][i - <span class="number">1</span>], min_w[fa[x][i - <span class="number">1</span>]][i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> nxt : g[x])</span><br><span class="line">        <span class="keyword">if</span> (nxt.to != fa[x][<span class="number">0</span>]) &#123;</span><br><span class="line">            fa[nxt.to][<span class="number">0</span>] = x;</span><br><span class="line">            min_w[nxt.to][<span class="number">0</span>] = nxt.w;</span><br><span class="line">            <span class="built_in">dfs</span>(nxt.to, std::<span class="built_in">min</span>(now_min, nxt.w), depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_lca</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d[x] &lt; d[y]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">while</span> (d[x] &gt; d[y])</span><br><span class="line">        x = fa[x][<span class="built_in"><span class="keyword">int</span></span>(<span class="built_in">log2</span>(d[x] - d[y]))];</span><br><span class="line">    <span class="keyword">if</span> (x == y) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">log2</span>(d[x]); i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fa[x][i] == fa[y][i]) <span class="keyword">continue</span>;</span><br><span class="line">        x = fa[x][i];</span><br><span class="line">        y = fa[y][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_min</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">1LL</span> &lt;&lt; <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">if</span> (d[x] &lt; d[y]) std::<span class="built_in">swap</span>(x, y);</span><br><span class="line">    <span class="keyword">while</span> (d[x] &gt; d[y]) &#123;</span><br><span class="line">        ans = std::<span class="built_in">min</span>(ans, min_w[x][<span class="built_in"><span class="keyword">int</span></span>(<span class="built_in">log2</span>(d[x] - d[y]))]);</span><br><span class="line">        x = fa[x][<span class="built_in"><span class="keyword">int</span></span>(<span class="built_in">log2</span>(d[x] - d[y]))];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    f[x] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> nxt : tree[x]) &#123;</span><br><span class="line">        <span class="built_in">dp</span>(nxt.to);</span><br><span class="line">        <span class="keyword">if</span> (flag[nxt.to]) f[x] += nxt.w;</span><br><span class="line">        <span class="keyword">else</span> f[x] += std::<span class="built_in">min</span>(f[nxt.to], nxt.w);</span><br><span class="line">    &#125;</span><br><span class="line">    tree[x].<span class="built_in">clear</span>();    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v, w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">        g[u].<span class="built_in">push_back</span>(&#123;v, w&#125;);</span><br><span class="line">        g[v].<span class="built_in">push_back</span>(&#123;u, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0x7fffffff</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">            flag[a[i]] = <span class="literal">true</span>;</span><br><span class="line">        &#125;            </span><br><span class="line">        std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + k + <span class="number">1</span>, [](<span class="keyword">int</span> x, <span class="keyword">int</span> y)&#123;<span class="keyword">return</span> dfn[x] &lt; dfn[y];&#125;);</span><br><span class="line">        std::vector&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        s.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> lca = <span class="built_in">get_lca</span>(a[i], s.<span class="built_in">back</span>());</span><br><span class="line">            <span class="keyword">if</span> (lca == s.<span class="built_in">back</span>()) &#123;</span><br><span class="line">                s.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (dfn[lca] &lt; dfn[s.<span class="built_in">back</span>()] &amp;&amp; dfn[lca] &lt; dfn[s[s.<span class="built_in">size</span>() - <span class="number">2</span>]]) &#123;</span><br><span class="line">                    tree[s[s.<span class="built_in">size</span>() - <span class="number">2</span>]].<span class="built_in">push_back</span>(&#123;s.<span class="built_in">back</span>(), <span class="built_in">get_min</span>(s.<span class="built_in">back</span>(), s[s.<span class="built_in">size</span>() - <span class="number">2</span>])&#125;);</span><br><span class="line">                    s.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (dfn[lca] &gt; dfn[s[s.<span class="built_in">size</span>() - <span class="number">2</span>]]) &#123; </span><br><span class="line">                    tree[lca].<span class="built_in">push_back</span>(&#123;s.<span class="built_in">back</span>(), <span class="built_in">get_min</span>(lca, s.<span class="built_in">back</span>())&#125;);</span><br><span class="line">                    s.<span class="built_in">pop_back</span>();</span><br><span class="line">                    s.<span class="built_in">push_back</span>(lca);</span><br><span class="line">                    s.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    tree[lca].<span class="built_in">push_back</span>(&#123;s.<span class="built_in">back</span>(), <span class="built_in">get_min</span>(lca, s.<span class="built_in">back</span>())&#125;);</span><br><span class="line">                    s.<span class="built_in">pop_back</span>();</span><br><span class="line">                    s.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (s.<span class="built_in">size</span>() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            tree[s[s.<span class="built_in">size</span>() - <span class="number">2</span>]].<span class="built_in">push_back</span>(&#123;s.<span class="built_in">back</span>(), <span class="built_in">get_min</span>(s.<span class="built_in">back</span>(), s[s.<span class="built_in">size</span>() - <span class="number">2</span>])&#125;);</span><br><span class="line">            s.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dp</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; i++)</span><br><span class="line">            flag[a[i]] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OI/ACM </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 树形 DP </tag>
            
            <tag> 虚树 </tag>
            
            <tag> 倍增 </tag>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>莫队算法模板（普通莫队、带修改莫队、回滚莫队）</title>
      <link href="/2021/11/13/mo&#39;s-algorithm/"/>
      <url>/2021/11/13/mo&#39;s-algorithm/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/posts/icpc/banner.png" alt="banner"></p><h1 id="普通莫队模板"><a href="#普通莫队模板" class="headerlink" title="普通莫队模板"></a>普通莫队模板</h1><h2 id="模板例题"><a href="#模板例题" class="headerlink" title="模板例题"></a>模板例题</h2><p><a href="https://www.luogu.com.cn/problem/P2709">Luogu P2709 小B的询问</a></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e4</span>, M = <span class="number">5e4</span>, K = <span class="number">5e4</span>, BLOCK = <span class="number">223</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i, l, r;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(query x) &#123;</span><br><span class="line">        <span class="keyword">return</span> (l - <span class="number">1</span>)/BLOCK != (x.l - <span class="number">1</span>)/BLOCK ? (l - <span class="number">1</span>)/BLOCK &lt; (x.l - <span class="number">1</span>)/BLOCK : r &lt; x.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; q[M + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N + <span class="number">1</span>], cnt[K + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans_tmp, ans[M + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> sign)</span> </span>&#123;</span><br><span class="line">    ans_tmp -= cnt[a[i]] * cnt[a[i]];</span><br><span class="line">    cnt[a[i]] += sign;</span><br><span class="line">    ans_tmp += cnt[a[i]] * cnt[a[i]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        q[i].i = i;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;q[i].l, &amp;q[i].r);</span><br><span class="line">    &#125;        </span><br><span class="line">    std::<span class="built_in">sort</span>(q + <span class="number">1</span>, q + m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> l = q[<span class="number">1</span>].l, r = q[<span class="number">1</span>].r;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) <span class="built_in">move</span>(i, <span class="number">1</span>);</span><br><span class="line">    ans[q[<span class="number">1</span>].i] = ans_tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; q[i].l) <span class="built_in">move</span>(l++, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q[i].l) <span class="built_in">move</span>(--l, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q[i].r) <span class="built_in">move</span>(r--, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r) <span class="built_in">move</span>(++r, <span class="number">1</span>);</span><br><span class="line">        ans[q[i].i] = ans_tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="带修改莫队模板"><a href="#带修改莫队模板" class="headerlink" title="带修改莫队模板"></a>带修改莫队模板</h1><h2 id="模板例题-1"><a href="#模板例题-1" class="headerlink" title="模板例题"></a>模板例题</h2><p><a href="https://www.luogu.com.cn/problem/P1903">Luogu P1903 [国家集训队]数颜色 / 维护队列</a></p><h2 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">133333</span>, M = <span class="number">133333</span>, K = <span class="number">1e6</span>, BLOCK = <span class="number">2609</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i, l, r, t;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(query x) &#123;</span><br><span class="line">        <span class="keyword">return</span> (l - <span class="number">1</span>)/BLOCK != (x.l - <span class="number">1</span>)/BLOCK ? (l - <span class="number">1</span>)/BLOCK &lt; (x.l - <span class="number">1</span>)/BLOCK : ((r - <span class="number">1</span>)/BLOCK != (x.r - <span class="number">1</span>)/BLOCK ? (r - <span class="number">1</span>)/BLOCK &lt; (x.r - <span class="number">1</span>)/BLOCK : i &lt; x.i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; q[M + <span class="number">1</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edit</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> pos, from, to;</span><br><span class="line">&#125; e[M + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N + <span class="number">1</span>], b[N + <span class="number">1</span>], cnt[K + <span class="number">1</span>], ans_tmp, ans[M + <span class="number">1</span>], cnt_query;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> sign)</span> </span>&#123;</span><br><span class="line">    cnt[a[i]] += sign;</span><br><span class="line">    <span class="keyword">if</span> (sign == <span class="number">1</span> &amp;&amp; cnt[a[i]] == <span class="number">1</span>) ++ans_tmp;</span><br><span class="line">    <span class="keyword">if</span> (sign == <span class="number">-1</span> &amp;&amp; cnt[a[i]] == <span class="number">0</span>) --ans_tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> sign, <span class="keyword">bool</span> flag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sign == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[e[i].to] == <span class="number">0</span>) ++ans_tmp;</span><br><span class="line">            <span class="keyword">if</span> (cnt[e[i].from] == <span class="number">1</span>) --ans_tmp;</span><br><span class="line">            ++cnt[e[i].to];</span><br><span class="line">            --cnt[e[i].from];</span><br><span class="line">        &#125;      </span><br><span class="line">        a[e[i].pos] = e[i].to;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[e[i].from] == <span class="number">0</span>) ++ans_tmp;</span><br><span class="line">            <span class="keyword">if</span> (cnt[e[i].to] == <span class="number">1</span>) --ans_tmp;</span><br><span class="line">            ++cnt[e[i].from];</span><br><span class="line">            --cnt[e[i].to];</span><br><span class="line">        &#125;     </span><br><span class="line">        a[e[i].pos] = e[i].from;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        b[i] = a[i];</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> op;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;op);</span><br><span class="line">        &#125; <span class="keyword">while</span> (op != <span class="string">&#x27;Q&#x27;</span> &amp;&amp; op != <span class="string">&#x27;R&#x27;</span>);        </span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;Q&#x27;</span>) &#123;</span><br><span class="line">            q[++cnt_query].t = i;</span><br><span class="line">            q[cnt_query].i = cnt_query;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;q[cnt_query].l, &amp;q[cnt_query].r);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;e[i].pos, &amp;e[i].to);</span><br><span class="line">            e[i].from = b[e[i].pos];</span><br><span class="line">            b[e[i].pos] = e[i].to;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">    std::<span class="built_in">sort</span>(q + <span class="number">1</span>, q + cnt_query + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> l = q[<span class="number">1</span>].l, r = q[<span class="number">1</span>].r, t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (t &lt; q[<span class="number">1</span>].t)</span><br><span class="line">        <span class="keyword">if</span> (e[++t].pos)</span><br><span class="line">            <span class="built_in">edit</span>(t, <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) <span class="built_in">move</span>(i, <span class="number">1</span>);    </span><br><span class="line">    ans[q[<span class="number">1</span>].i] = ans_tmp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cnt_query; i++) &#123;             </span><br><span class="line">        <span class="keyword">while</span> (l &lt; q[i].l) <span class="built_in">move</span>(l++, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span> (l &gt; q[i].l) <span class="built_in">move</span>(--l, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (r &gt; q[i].r) <span class="built_in">move</span>(r--, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span> (r &lt; q[i].r) <span class="built_in">move</span>(++r, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (t &lt; q[i].t)</span><br><span class="line">            <span class="keyword">if</span> (e[++t].pos)</span><br><span class="line">                <span class="built_in">edit</span>(t, <span class="number">1</span>, l &lt;= e[t].pos &amp;&amp; e[t].pos &lt;= r);</span><br><span class="line">        <span class="keyword">while</span> (t &gt; q[i].t) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e[t].pos)</span><br><span class="line">                <span class="built_in">edit</span>(t, <span class="number">-1</span>, l &lt;= e[t].pos &amp;&amp; e[t].pos &lt;= r);</span><br><span class="line">            --t;</span><br><span class="line">        &#125;                            </span><br><span class="line">        ans[q[i].i] = ans_tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt_query; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="回滚莫队模板（以只添加不删除为例）"><a href="#回滚莫队模板（以只添加不删除为例）" class="headerlink" title="回滚莫队模板（以只添加不删除为例）"></a>回滚莫队模板（以只添加不删除为例）</h1><h2 id="模板例题-2"><a href="#模板例题-2" class="headerlink" title="模板例题"></a>模板例题</h2><p><a href="https://www.luogu.com.cn/problem/P5906">Luogu P5906 【模板】回滚莫队&amp;不删除莫队</a></p><h2 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>, M = <span class="number">2e5</span>, BLOCK = <span class="number">447</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">query</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i, l, r;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(query x) &#123;</span><br><span class="line">        <span class="keyword">return</span> (l - <span class="number">1</span>)/BLOCK != (x.l - <span class="number">1</span>)/BLOCK ? (l - <span class="number">1</span>)/BLOCK &lt; (x.l - <span class="number">1</span>)/BLOCK : r &lt; x.r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; q[M + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N + <span class="number">1</span>], b[N + <span class="number">1</span>], left[N + <span class="number">1</span>], right[N + <span class="number">1</span>], rightr[N + <span class="number">1</span>], ans_r, ans_all, ans[M + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> left_delta[N + <span class="number">1</span>], right_delta[N + <span class="number">1</span>], rightr_delta[N + <span class="number">1</span>], left_delta_cnt, right_delta_cnt, rightr_delta_cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> flag)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!left[a[i]]) &#123;</span><br><span class="line">            left[a[i]] = i;</span><br><span class="line">            left_delta[++left_delta_cnt] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!right[a[i]]) right_delta[++right_delta_cnt] = a[i];</span><br><span class="line">        <span class="keyword">if</span> (!rightr[a[i]]) rightr_delta[++rightr_delta_cnt] = a[i];</span><br><span class="line">        right[a[i]] = rightr[a[i]] = i;</span><br><span class="line">        ans_r = std::<span class="built_in">max</span>(ans_r, right[a[i]] - left[a[i]]);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!right[a[i]]) &#123;</span><br><span class="line">            right[a[i]] = i;</span><br><span class="line">            right_delta[++right_delta_cnt] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ans_all = std::<span class="built_in">max</span>(ans_all, right[a[i]] - i);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first[N + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; ++i)</span><br><span class="line">        first[a[i]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!first[a[i]]) first[a[i]] = i;</span><br><span class="line">        <span class="keyword">else</span> ans_all = std::<span class="built_in">max</span>(ans_all, i - first[a[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        b[i] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(b + <span class="number">1</span>, b + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> n_unique = std::<span class="built_in">unique</span>(b + <span class="number">1</span>, b + n + <span class="number">1</span>) - b - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        a[i] = std::<span class="built_in">lower_bound</span>(b + <span class="number">1</span>, b + n_unique + <span class="number">1</span>, a[i]) - b;    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        q[i].i = i;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;q[i].l, &amp;q[i].r);</span><br><span class="line">    &#125;        </span><br><span class="line">    std::<span class="built_in">sort</span>(q + <span class="number">1</span>, q + m + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> l, r;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((q[i].l - <span class="number">1</span>) / BLOCK == (q[i].r - <span class="number">1</span>) / BLOCK) &#123;</span><br><span class="line">            ans_all = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">calc</span>(q[i].l, q[i].r);</span><br><span class="line">            flag = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;            </span><br><span class="line">            l = ((q[i].l - <span class="number">1</span>) / BLOCK + <span class="number">1</span>) * BLOCK + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (flag || (q[i].l - <span class="number">1</span>) / BLOCK != (q[i - <span class="number">1</span>].l - <span class="number">1</span>) / BLOCK) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= left_delta_cnt; ++j)</span><br><span class="line">                    left[left_delta[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= rightr_delta_cnt; ++j)</span><br><span class="line">                    rightr[rightr_delta[j]] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= right_delta_cnt; ++j)</span><br><span class="line">                    right[right_delta[j]] = <span class="number">0</span>;</span><br><span class="line">                r = l - <span class="number">1</span>;</span><br><span class="line">                ans_r = left_delta_cnt = rightr_delta_cnt = right_delta_cnt= <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= right_delta_cnt; ++j)</span><br><span class="line">                right[right_delta[j]] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= rightr_delta_cnt; ++j)</span><br><span class="line">                right[rightr_delta[j]] = rightr[rightr_delta[j]];</span><br><span class="line">            right_delta_cnt = rightr_delta_cnt;</span><br><span class="line">            <span class="keyword">while</span> (r &lt; q[i].r) <span class="built_in">add</span>(++r, <span class="number">1</span>); </span><br><span class="line">            ans_all = ans_r;          </span><br><span class="line">            <span class="keyword">while</span> (l &gt; q[i].l) <span class="built_in">add</span>(--l, <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ans[q[i].i] = ans_all;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans[i]);        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OI/ACM </tag>
            
            <tag> 莫队 </tag>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可持久化并查集模板（带路径压缩、按秩合并优化）</title>
      <link href="/2021/11/06/persistent-union-find-set/"/>
      <url>/2021/11/06/persistent-union-find-set/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/posts/icpc/banner.png" alt="banner"></p><h2 id="模板例题"><a href="#模板例题" class="headerlink" title="模板例题"></a>模板例题</h2><p><a href="https://www.luogu.com.cn/problem/P3402">Luogu P3402 可持久化并查集</a></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span>, M = <span class="number">2e5</span>, Log4N = <span class="number">19</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val, rank, lchild, rchild;</span><br><span class="line">&#125; tree[<span class="number">4</span> * N + M * Log4N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> init[N + <span class="number">1</span>], root[M + <span class="number">1</span>], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = ++tot;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tree[now].val = init[l];</span><br><span class="line">        tree[now].rank = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    tree[now].lchild = <span class="built_in">build</span>(l, mid);</span><br><span class="line">    tree[now].rchild = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> target, <span class="keyword">int</span> newroot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = ++tot;</span><br><span class="line">    tree[now] = tree[x];</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tree[now].val = newroot;</span><br><span class="line">        tree[newroot].rank = std::<span class="built_in">max</span>(tree[newroot].rank, tree[now].rank + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (target &lt;= mid)</span><br><span class="line">        tree[now].lchild = <span class="built_in">update</span>(tree[x].lchild, l, mid, target, newroot);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tree[now].rchild = <span class="built_in">update</span>(tree[x].rchild, mid + <span class="number">1</span>, r, target, newroot);</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> tree[x].val;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (target &lt;= mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(tree[x].lchild, l, mid, target);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(tree[x].rchild, mid + <span class="number">1</span>, r, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="built_in">query</span>(x, l, r, target);</span><br><span class="line">    <span class="keyword">if</span> (ans == target) <span class="keyword">return</span> ans;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">getroot</span>(x, l, r, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        init[i] = i;</span><br><span class="line">    root[<span class="number">0</span>] = <span class="built_in">build</span>(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">int</span> op, a, b, k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            <span class="keyword">int</span> root_a = <span class="built_in">getroot</span>(root[i - <span class="number">1</span>], <span class="number">1</span>, n, a);</span><br><span class="line">            <span class="keyword">int</span> root_b = <span class="built_in">getroot</span>(root[i - <span class="number">1</span>], <span class="number">1</span>, n, b);</span><br><span class="line">            <span class="keyword">if</span> (tree[root_a].rank &lt; tree[root_b].rank)</span><br><span class="line">                root[i] = <span class="built_in">update</span>(root[i - <span class="number">1</span>], <span class="number">1</span>, n, root_a, root_b);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                root[i] = <span class="built_in">update</span>(root[i - <span class="number">1</span>], <span class="number">1</span>, n, root_b, root_a);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">            root[i] = root[k];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            root[i] = root[i - <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">getroot</span>(root[i], <span class="number">1</span>, n, a) == <span class="built_in">getroot</span>(root[i], <span class="number">1</span>, n, b));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OI/ACM </tag>
            
            <tag> 并查集 </tag>
            
            <tag> 主席树 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可持久化线段树（主席树）模板</title>
      <link href="/2021/11/05/persistent-segment-tree/"/>
      <url>/2021/11/05/persistent-segment-tree/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/posts/icpc/banner.png" alt="banner"></p><h1 id="单点修改单点查询模板"><a href="#单点修改单点查询模板" class="headerlink" title="单点修改单点查询模板"></a>单点修改单点查询模板</h1><h2 id="模板例题"><a href="#模板例题" class="headerlink" title="模板例题"></a>模板例题</h2><p><a href="https://www.luogu.com.cn/problem/P3919">Luogu P3919【模板】可持久化线段树 1（可持久化数组）</a></p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span>, M = <span class="number">1e6</span>, Log4N = <span class="number">22</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val, lchild, rchild;</span><br><span class="line">&#125; tree[<span class="number">4</span> * N + M * Log4N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N + <span class="number">1</span>], root[M + <span class="number">1</span>], tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = ++tot;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tree[now].val = a[l];</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    tree[now].lchild = <span class="built_in">build</span>(l, mid);</span><br><span class="line">    tree[now].rchild = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> target, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = ++tot;</span><br><span class="line">    tree[now] = tree[x];</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tree[now].val = val;</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (target &lt;= mid)</span><br><span class="line">        tree[now].lchild = <span class="built_in">update</span>(tree[x].lchild, l, mid, target, val);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tree[now].rchild = <span class="built_in">update</span>(tree[x].rchild, mid + <span class="number">1</span>, r, target, val);</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> tree[x].val;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (target &lt;= mid)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(tree[x].lchild, l, mid, target);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(tree[x].rchild, mid + <span class="number">1</span>, r, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    root[<span class="number">0</span>] = <span class="built_in">build</span>(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> ver, op, target, val;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;ver, &amp;op, &amp;target);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;val);</span><br><span class="line">            root[i] = <span class="built_in">update</span>(root[ver], <span class="number">1</span>, n, target, val); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root[i] = ++tot;</span><br><span class="line">            tree[root[i]] = tree[root[ver]];</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(root[i], <span class="number">1</span>, n, target));</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="单点修改区间查询模板"><a href="#单点修改区间查询模板" class="headerlink" title="单点修改区间查询模板"></a>单点修改区间查询模板</h1><h2 id="模板例题-1"><a href="#模板例题-1" class="headerlink" title="模板例题"></a>模板例题</h2><p><a href="https://www.luogu.com.cn/problem/P3834">Luogu P3834【模板】可持久化线段树 2</a></p><h2 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2e5</span>, Log4N = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val, lchild, rchild;</span><br><span class="line">&#125; tree[<span class="number">4</span> * N + N * Log4N];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">item</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> pos, val;</span><br><span class="line">&#125; a[N + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root[N + <span class="number">1</span>], val_unique[N + <span class="number">1</span>], tot, cnt_unique;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = ++tot;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        tree[now].val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    tree[now].lchild = <span class="built_in">build</span>(l, mid);</span><br><span class="line">    tree[now].rchild = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> now = ++tot;</span><br><span class="line">    tree[now] = tree[x];</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= target &amp;&amp; target &lt;= r) &#123;</span><br><span class="line">        tree[now].val++;</span><br><span class="line">        <span class="keyword">if</span> (l == r)</span><br><span class="line">            <span class="keyword">return</span> now;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (target &lt;= mid)</span><br><span class="line">        tree[now].lchild = <span class="built_in">update</span>(tree[x].lchild, l, mid, target);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tree[now].rchild = <span class="built_in">update</span>(tree[x].rchild, mid + <span class="number">1</span>, r, target);</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> st, <span class="keyword">int</span> ed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (st &lt;= l &amp;&amp; r &lt;= ed) <span class="keyword">return</span> tree[x].val;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (mid &gt;= st) ans += <span class="built_in">query</span>(tree[x].lchild, l, mid, st, ed);</span><br><span class="line">    <span class="keyword">if</span> (mid + <span class="number">1</span> &lt;= ed) ans += <span class="built_in">query</span>(tree[x].rchild, mid + <span class="number">1</span>, r, st, ed);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        a[i].pos = i;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i].val);</span><br><span class="line">    &#125;       </span><br><span class="line">    root[<span class="number">0</span>] = <span class="built_in">build</span>(<span class="number">1</span>, n);</span><br><span class="line">    std::<span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, [](item x, item y)&#123;<span class="keyword">return</span> x.val &lt; y.val;&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">1</span> || a[i].val != a[i - <span class="number">1</span>].val) &#123;</span><br><span class="line">            ++cnt_unique;</span><br><span class="line">            val_unique[cnt_unique] = a[i].val;</span><br><span class="line">            root[cnt_unique] = <span class="built_in">update</span>(root[cnt_unique - <span class="number">1</span>], <span class="number">1</span>, n, a[i].pos);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root[cnt_unique] = <span class="built_in">update</span>(root[cnt_unique], <span class="number">1</span>, n, a[i].pos);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;        </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;k);</span><br><span class="line">        <span class="keyword">int</span> st = <span class="number">1</span>, ed = cnt_unique + <span class="number">1</span>, ans = <span class="number">0x7fffffff</span>;        </span><br><span class="line">        <span class="keyword">while</span> (st &lt; ed) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = st + ed &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> result = <span class="built_in">query</span>(root[mid], <span class="number">1</span>, n, l, r);</span><br><span class="line">            <span class="keyword">if</span> (result &gt;= k) &#123;</span><br><span class="line">                ans = std::<span class="built_in">min</span>(ans, val_unique[mid]);</span><br><span class="line">                ed = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 模板 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OI/ACM </tag>
            
            <tag> 主席树 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HoneyTuner 一个简洁易用的音频处理工具箱</title>
      <link href="/2021/09/17/introducing-honeytuner/"/>
      <url>/2021/09/17/introducing-honeytuner/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/posts/introducing-honeytuner/banner.png" alt="banner"></p><h1 id="产品介绍"><a href="#产品介绍" class="headerlink" title="产品介绍"></a>产品介绍</h1><p>HoneyTuner 是一个简洁易用的音频处理工具箱，由 Honeta 于 2020 年 10 月 18 日启动开发，初版完工于 2021 年 1 月 5 日。本软件使用了 C / C++ / HTML / CSS / Node.js 等语言并基于 <a href="https://www.electronjs.org/">Electron 框架</a>，支持对 MP3 格式音频文件进行一系列修改操作。目前已经支持的操作有：</p><ul><li>将 MP3 音频文件解码为 WAV 波形音频文件（<a href="https://github.com/mackron/dr_libs">mackron/dr_libs</a>）</li><li>增大或减小音频任意片段的音量</li><li>倒置音频的任意片段</li><li>删除音频的任意片段</li><li>在一个音频的任意位置拼接入另一个音频的任意片段</li><li>在一个音频的任意位置叠加入另一个音频的任意片段</li><li>在上述两个功能的两个操作音频采样率不同时进行采样率同化</li><li>去除音频任意片段的任意声道</li><li>实现音频任意片段的变调加速与减速，以及不变调减速</li><li>为音频任意片段添加任意幅度的混响效果</li><li>将音频任意片段的音调升高任意幅度</li><li>将音频任意片段复制到该音频的其它位置</li><li>将音频任意片段移动到该音频的其它位置</li><li>撤销之前作出的修改</li><li>调用系统播放器试听音频的当前修改版本</li><li>将 WAV 波形音频文件编码为 MP3 音频文件（<a href="https://github.com/mackron/dr_libs">mackron/dr_libs</a>）</li></ul><p>这些功能的使用方式，在软件对应功能界面有详尽的说明。更多功能与特性正在到来的路上，敬请期待。</p><h1 id="产品界面"><a href="#产品界面" class="headerlink" title="产品界面"></a>产品界面</h1><p><img src="/images/posts/introducing-honeytuner/interface.png" alt="HoneyTuner 首页"><br><img src="/images/posts/introducing-honeytuner/decoder.png" alt="HoneyTuner 音频解码"><br><img src="/images/posts/introducing-honeytuner/merge.png" alt="HoneyTuner 片段拼接"><br><img src="/images/posts/introducing-honeytuner/discard.png" alt="HoneyTuner 撤销修改"></p><h1 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a>下载链接</h1><p>最新版本：1.0.2</p><ul><li><a href="https://husthxj.top/files/honeytuner-win32-x64-1.0.2.zip">直接下载</a></li><li><a href="https://pan.baidu.com/s/1SvGv3JoYG2ZOTngY289OPA">百度网盘</a> （提取码: x6yf）</li><li><a href="https://github.com/HUST-hxj/HoneyTuner/releases/download/1.0.2/honeytuner-win32-x64-1.0.2.zip">Github</a></li></ul><h1 id="版本日志"><a href="#版本日志" class="headerlink" title="版本日志"></a>版本日志</h1><ul><li><p>2021.09.17 Ver 1.0.2 <strong>(Latest)</strong></p><ul><li>首个正式发布版本</li><li>添加在 Windows 系统下使用的源码自动编译脚本（需安装 Node.js 和 GCC）</li></ul></li><li><p>2021.01.11 Ver 1.0.1</p><ul><li>添加窗口大小自定义</li><li>对部分细节进行优化</li></ul></li><li><p>2021.01.05 Ver 1.0.0</p><ul><li>HoneyTuner 的第一个版本</li></ul></li></ul><h1 id="开源地址"><a href="#开源地址" class="headerlink" title="开源地址"></a>开源地址</h1><ul><li><a href="https://github.com/Honeta/HoneyTuner">Github</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 作品 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Electron </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 学习笔记 &amp; 操作速查</title>
      <link href="/2020/11/10/learn-git/"/>
      <url>/2020/11/10/learn-git/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/posts/learn-git/banner.png" alt="banner"></p><h1 id="学习地址"><a href="#学习地址" class="headerlink" title="学习地址"></a>学习地址</h1><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰的 Git 教程</a></p><h1 id="内容摘要"><a href="#内容摘要" class="headerlink" title="内容摘要"></a>内容摘要</h1><h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>初始化一个 Git 仓库，使用 <code>git init</code> 命令。</p><p>添加文件到 Git 仓库，分两步：<br>使用命令 <code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</p><p>使用命令 <code>git commit -m &lt;message&gt;</code>，完成。</p><p>要随时掌握工作区的状态，使用 <code>git status</code> 命令。</p><h2 id="时光机穿梭"><a href="#时光机穿梭" class="headerlink" title="时光机穿梭"></a>时光机穿梭</h2><p>如果 <code>git status</code> 告诉你有文件被修改过，用 <code>git diff</code> 可以查看修改内容。</p><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>HEAD 指向的版本就是当前版本，因此，Git 允许我们在版本的历史之间穿梭，使用命令 <code>git reset --hard commit_id</code>。</p><p>穿梭前，用 <code>git log</code> 可以查看提交历史，以便确定要回退到哪个版本。</p><p>要重返未来，用 <code>git reflog</code> 查看命令历史，以便确定要回到未来的哪个版本。</p><h3 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h3><p>工作区（Working Directory）就是你在电脑里能看到的目录。</p><p>版本库（Repository）：工作区有一个隐藏目录 .git，这个不算工作区，而是 Git 的版本库。</p><h3 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h3><p>Git 管理的是修改，而不是文件。</p><p>提交修改后，用 <code>git diff HEAD -- file</code> 命令可以查看工作区和版本库里面最新版本的区别。</p><h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p>场景 1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令 <code>git checkout -- file</code>。</p><p>场景 2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令 <code>git reset HEAD &lt;file&gt;</code>，就回到了场景 1，第二步按场景1操作。</p><p>场景 3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>命令 <code>git rm</code> 用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</p><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><h3 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h3><p>要关联一个远程库，使用命令 <code>git remote add origin git@server-name:path/repo-name.git</code>；</p><p>关联后，使用命令 <code>git push -u origin master</code> 第一次推送 master 分支的所有内容；</p><p>此后，每次本地提交后，只要有必要，就可以使用命令 <code>git push origin master</code> 推送最新修改；</p><h3 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h3><p>要克隆一个仓库，首先必须知道仓库的地址，然后使用 <code>git clone</code> 命令克隆。</p><p>Git 支持多种协议，包括 https，但 ssh 协议速度最快。</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><h3 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h3><p>Git 鼓励大量使用分支：</p><p>查看分支：<code>git branch</code></p><p>创建分支：<code>git branch &lt;name&gt;</code></p><p>切换分支：<code>git checkout &lt;name&gt;</code> 或者 <code>git switch &lt;name&gt;</code></p><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code> 或者 <code>git switch -c &lt;name&gt;</code></p><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p><p>删除分支：<code>git branch -d &lt;name&gt;</code></p><h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>当 Git 无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p><p>解决冲突就是把 Git 合并失败的文件手动编辑为我们希望的内容，再提交。</p><p>用 <code>git log --graph</code> 命令可以看到分支合并图。</p><h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><p>Git 分支十分强大，在团队开发中应该充分应用。</p><p>合并分支时，加上 <code>--no-ff</code> 参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而 fast forward 合并就看不出来曾经做过合并。</p><h3 id="Bug-分支"><a href="#Bug-分支" class="headerlink" title="Bug 分支"></a>Bug 分支</h3><p>修复 bug 时，我们会通过创建新的 bug 分支进行修复，然后合并，最后删除；</p><p>当手头工作没有完成时，先把工作现场 <code>git stash</code> 一下，然后去修复 bug，修复后，再 <code>git stash pop</code>，回到工作现场；</p><p>在 master 分支上修复的 bug，想要合并到当前 dev 分支，可以用 <code>git cherry-pick &lt;commit&gt;</code> 命令，把 bug 提交的修改“复制”到当前分支，避免重复劳动。</p><h3 id="Feature-分支"><a href="#Feature-分支" class="headerlink" title="Feature 分支"></a>Feature 分支</h3><p>开发一个新 feature，最好新建一个分支；</p><p>如果要丢弃一个没有被合并过的分支，可以通过 <code>git branch -D &lt;name&gt;</code> 强行删除。</p><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>查看远程库信息，使用 <code>git remote -v</code>；</p><p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p><p>从本地推送分支，使用 <code>git push origin branch-name</code>，如果推送失败，先用 <code>git pull</code> 抓取远程的新提交；</p><p>在本地创建和远程分支对应的分支，使用 <code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</p><p>建立本地分支和远程分支的关联，使用 <code>git branch --set-upstream branch-name origin/branch-name</code>；</p><p>从远程抓取分支，使用 <code>git pull</code>，如果有冲突，要先处理冲突。</p><h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h3><p>rebase 操作可以把本地未 push 的分叉提交历史整理成直线；</p><p>rebase 的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p><h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>Git 的标签虽然是版本库的快照，但其实它就是指向某个 commit 的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p><p>tag 就是一个让人容易记住的有意义的名字，它跟某个 commit 绑在一起。</p><h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>命令 <code>git tag &lt;tagname&gt;</code> 用于新建一个标签，默认为 HEAD，也可以指定一个 commit id；</p><p>命令 <code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code> 可以指定标签信息；</p><p>命令 <code>git tag</code> 可以查看所有标签。</p><h3 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h3><p>命令 <code>git push origin &lt;tagname&gt;</code> 可以推送一个本地标签；</p><p>命令 <code>git push origin --tags</code> 可以推送全部未推送过的本地标签；</p><p>命令 <code>git tag -d &lt;tagname&gt;</code> 可以删除一个本地标签；</p><p>命令 <code>git push origin :refs/tags/&lt;tagname&gt;</code> 可以删除一个远程标签。</p><h2 id="使用-GitHub"><a href="#使用-GitHub" class="headerlink" title="使用 GitHub"></a>使用 GitHub</h2><p>在 GitHub 上，可以任意 Fork 开源仓库；</p><p>自己拥有 Fork 后的仓库的读写权限；</p><p>可以 pull request 给官方仓库来贡献代码。</p><h2 id="GitFlow"><a href="#GitFlow" class="headerlink" title="GitFlow"></a>GitFlow</h2><p>Gitflow 使用两个分支来记录项目开发的历史，而不是使用单一的 master 分支。在 Gitflow 流程中，master 只是用于保存官方的发布历史，而 develop 分支才是用于集成各种功能开发的分支。使用版本号为 master 上的所有提交打标签（tag）也很方便。</p><p>每一个新功能的开发都应该各自使用独立的分支（feature）。为了备份或便于团队之间的合作，这种分支也可以被推送到中央仓库。但是，在创建新的功能开发分支时，父分支应该选择 develop（而不是 master）。当功能开发完成时，改动的代码应该被合并（merge）到 develop 分支。功能开发永远不应该直接牵扯到 master。</p><p>一旦 develop 分支积聚了足够多的新功能（或者预定的发布日期临近了），你可以基于 develop 分支建立一个用于产品发布的分支（release）。这个分支的创建意味着一个发布周期的开始，也意味着本次发布不会再增加新的功能——在这个分支上只能修复 bug，做一些文档工作或者跟发布相关的任务。在一切准备就绪的时候，这个分支会被合并入 master，并且用版本号打上标签。另外，发布分支上的改动还应该合并入 develop 分支——在发布周期内，develop 分支仍然在被使用（一些开发者会把其他功能集成到 develop 分支）。</p><p>使用专门的一个分支来为发布做准备的好处是，在一个团队忙于当前的发布的同时，另一个团队可以继续为接下来的一次发布开发新功能。这也有助于清晰表明开发的状态，比如说，团队在汇报状态时可以轻松使用这样的措辞，“这星期我们要为发布 4.0 版本做准备。”从代码仓库的结构上也能直接反映出来。常用的一些措辞还有：基于 develop 新建分支，合并入 master；命名规则为：release- 或 release/</p><p>发布后的维护工作或者紧急问题的快速修复也需要使用一个独立的分支。这是唯一一种可以直接基于 master 创建的分支。一旦问题被修复了，所做的改动应该被合并入 master 和 develop 分支（或者用于当前发布的分支）。在这之后，master 上还要使用更新的版本号打好标签。</p><p>这种为解决紧急问题专设的绿色通道，让团队不必打乱当前的工作流程，也不必等待下一次的产品发布周期。你可以把用于维护的分支看成是依附于 master 的一种特别的发布分支。</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P3931 一道难题 Tree 题解</title>
      <link href="/2019/10/10/luogu-p3931/"/>
      <url>/2019/10/10/luogu-p3931/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/posts/luogu/banner.png" alt="banner"></p><h2 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h2><p><a href="https://www.luogu.com.cn/problem/P3931">https://www.luogu.com.cn/problem/P3931</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>根据题意，本题与最小割问题极为相似，根据最大流最小割定理，本题可转化为求网络最大流。</p><span id="more"></span><p>还未学习该知识的，请先学习，然后建议先写模板题练习一下。</p><p>首先，提醒一个雷区！题目给的是一个无向图，故我们需要先从树根开始对这个无向图进行dfs预处理，把无向边转换成有向边。（WA 20分的绝大多数都忽略了这一点，包括我）</p><p>然后，一个网络流图不仅要有源点（即树的根节点），还要有汇点。我们假设n+1即为汇点，让所有的叶子节点都伸出一条指向n+1的有向边（这个可以在dfs预处理时顺便处理一下，而且要记得建反向边）。</p><p>题目要求任何叶子节点都和根节点不连通，而这个条件恰恰和汇点和源点不连通是等价的（因为所有叶子节点都和汇点连通，故但凡有任何一个叶子节点和根节点连通，汇点和源点都是连通的）。</p><p>至此，我们已经完成了构造，接下来问题就只剩下求网络流图的最大流了。这里有多种算法可以选择，我使用的是dinic算法，具体实现不再赘述。在存图时我采取的是vector存图，下面的代码供参考。</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I 0x3f3f3f3f<span class="comment">//无穷大</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">road</span>&#123;</span><span class="keyword">int</span> to,w;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span><span class="keyword">int</span> to,w;&#125;e[N&lt;&lt;<span class="number">2</span>];<span class="comment">//存储边的信息，考虑到双向建边（包括叶子节点与汇点）的问题，保险起见开四倍数组</span></span><br><span class="line">vector&lt;road&gt; g[N];<span class="comment">//存初始的无向图</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v[N];<span class="comment">//存转化之后的有向图</span></span><br><span class="line"><span class="keyword">int</span> n,s,t,t1,t2,t3,cnt,ans,d[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> fa)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(g[x].<span class="built_in">size</span>()==<span class="number">1</span>&amp;&amp;g[x][<span class="number">0</span>].to==fa)<span class="comment">//判叶子节点，和汇点建边</span></span><br><span class="line">    &#123;</span><br><span class="line">      v[x].<span class="built_in">push_back</span>(cnt);</span><br><span class="line">      e[cnt].to=t;</span><br><span class="line">      e[cnt++].w=I;</span><br><span class="line">      v[t].<span class="built_in">push_back</span>(cnt);<span class="comment">//建反向边</span></span><br><span class="line">      e[cnt].to=x;</span><br><span class="line">      e[cnt++].w=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g[x].<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> to=g[x][i].to,w=g[x][i].w;</span><br><span class="line">      <span class="keyword">if</span>(to==fa)<span class="keyword">continue</span>;</span><br><span class="line">      v[x].<span class="built_in">push_back</span>(cnt);</span><br><span class="line">      e[cnt].to=to;</span><br><span class="line">      e[cnt++].w=w;</span><br><span class="line">      v[to].<span class="built_in">push_back</span>(cnt);<span class="comment">//建反向边</span></span><br><span class="line">      e[cnt].to=x;</span><br><span class="line">      e[cnt++].w=<span class="number">0</span>;</span><br><span class="line">      <span class="built_in">pre</span>(to,x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">  <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(d));</span><br><span class="line">  d[s]=<span class="number">1</span>;</span><br><span class="line">  q.<span class="built_in">push</span>(s);</span><br><span class="line">  <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> now=q.<span class="built_in">front</span>();</span><br><span class="line">      q.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v[now].<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> temp=v[now][i];</span><br><span class="line">      <span class="keyword">int</span> to=e[temp].to,w=e[temp].w;</span><br><span class="line">      <span class="keyword">if</span>(!d[to]&amp;&amp;w)</span><br><span class="line">        &#123;</span><br><span class="line">          d[to]=d[now]+<span class="number">1</span>;</span><br><span class="line">          q.<span class="built_in">push</span>(to);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> d[t];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now,<span class="keyword">int</span> minn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(now==t)<span class="keyword">return</span> minn;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v[now].<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> temp=v[now][i];</span><br><span class="line">      <span class="keyword">int</span> to=e[temp].to,w=e[temp].w;</span><br><span class="line">      <span class="keyword">if</span>(d[to]==d[now]+<span class="number">1</span>&amp;&amp;w)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> res=<span class="built_in">dfs</span>(to,<span class="built_in">min</span>(minn,w));</span><br><span class="line">      <span class="keyword">if</span>(res)</span><br><span class="line">        &#123;</span><br><span class="line">          e[temp].w-=res;</span><br><span class="line">          e[temp^<span class="number">1</span>].w+=res;</span><br><span class="line">          <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;s);</span><br><span class="line">  t=n+<span class="number">1</span>;<span class="comment">//设置汇点</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;t1,&amp;t2,&amp;t3);</span><br><span class="line">      g[t1].<span class="built_in">push_back</span>(&#123;t2,t3&#125;);<span class="comment">//存无向图</span></span><br><span class="line">      g[t2].<span class="built_in">push_back</span>(&#123;t1,t3&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">pre</span>(s,s);<span class="comment">//预处理，无向图转有向图</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">bfs</span>())<span class="comment">//dinic算法求最大流</span></span><br><span class="line">    ans+=<span class="built_in">dfs</span>(s,I);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> OI/ACM </tag>
            
            <tag> 最大流 </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 广度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P3014 牛线Cow Line 题解</title>
      <link href="/2019/10/09/luogu-p3014/"/>
      <url>/2019/10/09/luogu-p3014/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/posts/luogu/banner.png" alt="banner"></p><h2 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h2><p><a href="https://www.luogu.com.cn/problem/P3014">https://www.luogu.com.cn/problem/P3014</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>康托展开（使用树状数组优化）与逆康托展开。</p><span id="more"></span><p>在康托展开时，需要计算每一位数字在它和它以后的所有数字中是第几大的数，在这里我使用了树状数组对算法的时间复杂度进行了优化。</p><p>我们设add(x,y)是将x加上y，ask(x)是查询x的前缀和。在预处理时，我们对从1到n的每一个i都分别add(i,1),假设我们当前算到了第i位数a[i]，首先我们add(a[i],-1),这个操作就相当于把a[i]划掉，而在第i位之前出现过的数都已经被我们提前划掉了。那么ask(a[i])即为在第i位之后出现的比a[i]小的数的总个数（即：还未被划掉的比a[i]小的数的总个数）。这样，我们就巧妙地利用了树状数组的性质对康托展开进行了优化。在数据较大时，这种优化作用是极为显著的。</p><p>最后提醒一下：一定要开long long！</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">ll n,k,t2,ans,fact[<span class="number">21</span>],tree[<span class="number">21</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">21</span>];</span><br><span class="line"><span class="keyword">char</span> t1;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(ll x,ll y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(;x&lt;=n;x+=x&amp;-x)tree[x]+=y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">ask</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ll res=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;x;x-=x&amp;-x)res+=tree[x];</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">  fact[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;n;i++)fact[i]=fact[i<span class="number">-1</span>]*i;<span class="comment">//递推求阶乘</span></span><br><span class="line">  <span class="keyword">while</span>(k--)</span><br><span class="line">    &#123;</span><br><span class="line">      cin&gt;&gt;t1;</span><br><span class="line">      <span class="built_in">memset</span>(tree,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(tree));</span><br><span class="line">      <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">      <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">add</span>(i,<span class="number">1</span>);<span class="comment">//预处理树状数组</span></span><br><span class="line">      <span class="built_in"><span class="keyword">switch</span></span>(t1)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>:<span class="comment">//康托展开（树状数组优化）</span></span><br><span class="line">      ans=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;t2);</span><br><span class="line">          <span class="built_in">add</span>(t2,<span class="number">-1</span>);<span class="comment">//划掉这个数</span></span><br><span class="line">          ans+=<span class="built_in">ask</span>(t2)*fact[n-i];<span class="comment">//运用树状数组求这位数字在它和它以后的所有数字中是第几大的数</span></span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans+<span class="number">1</span>);<span class="comment">//记得求出来的结果要加1</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;P&#x27;</span>:<span class="comment">//逆康托展开</span></span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;t2);</span><br><span class="line">      t2--;</span><br><span class="line">      <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">          ll temp=t2/fact[n-i];</span><br><span class="line">          <span class="keyword">for</span>(ll j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span>(vis[j])<span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">if</span>(!temp)</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>,j);</span><br><span class="line">              vis[j]=<span class="number">1</span>;</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          temp--;</span><br><span class="line">        &#125;</span><br><span class="line">          t2%=fact[n-i];</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> OI/ACM </tag>
            
            <tag> 康托展开 </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P1280 尼克的任务 题解</title>
      <link href="/2019/10/05/luogu-p1280/"/>
      <url>/2019/10/05/luogu-p1280/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/posts/luogu/banner.png" alt="banner"></p><h2 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h2><p><a href="https://www.luogu.com.cn/problem/P1280">https://www.luogu.com.cn/problem/P1280</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>动态规划，具体步骤如下。</p><span id="more"></span><ul><li><p>预处理阶段<br>设置两个bool数组begin、end，begin数组记录每个时间点有无任务开始，end数组记录每个时间点有无任务结束。每次输入一个任务的起止时间后，更新两个bool数组并建立一条从终止时间到起止时间的有向边，用vector实现的二维数组存储。</p></li><li><p>DP阶段<br>从后往前进行一遍扫描。设置数组f，f[i]记录从时间点i到工作日结束之间最长的空暇时间（即：时间点i的“逆推最大空暇时间”）。</p></li></ul><p>扫描到有任务结束的时间点时，以为此时任务刚结束，从下一分钟才会进入空暇状态，故我们用当前时间下一分钟的“逆推最大空暇时间”分别对【当前时间结束的所有任务】的起始时间的“逆推最大空暇时间”进行比较，若更大则替换之。这一步把所有有任务开始的时间点的“逆推最大空暇时间”已经更新为最优解。</p><p>同时，若没有任务在当前时间开始，则下一分钟的“逆推最大空暇时间”加一之后即为当前时间的“逆推最大空暇时间”。</p><p>一遍扫描过后，f[1]即为从工作日开始到工作日结束的“逆推最大空暇时间”，直接输出即可。</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,k,t,p,now,f[<span class="number">10001</span>];</span><br><span class="line"><span class="keyword">bool</span> begin[<span class="number">10001</span>],end[<span class="number">10001</span>];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; v[<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&gt;y?x:y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=k;i++)<span class="comment">//预处理阶段</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;p,&amp;t);</span><br><span class="line">      begin[p]=<span class="number">1</span>;<span class="comment">//做标记</span></span><br><span class="line">      end[p+t<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">      v[p+t<span class="number">-1</span>].<span class="built_in">push_back</span>(p);<span class="comment">//建边</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&gt;=<span class="number">1</span>;i--)<span class="comment">//DP阶段</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(end[i])</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;v[i].<span class="built_in">size</span>();k++)</span><br><span class="line">      f[v[i][k]]=<span class="built_in">max</span>(f[v[i][k]],f[i+<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">if</span>(!begin[i])f[i]=f[i+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> OI/ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P1064 金明的预算方案 题解</title>
      <link href="/2019/10/05/luogu-p1064/"/>
      <url>/2019/10/05/luogu-p1064/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/posts/luogu/banner.png" alt="banner"></p><h2 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h2><p><a href="https://www.luogu.com.cn/problem/P1064">https://www.luogu.com.cn/problem/P1064</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>根据题意我们可以得知，只选主件、只选主件和第一个附件、只选主件和第二个附件、主件和两个附件都选这四种情况是互斥的，只能且必须任选其一，符合分组背包类似于“每组物品中只能选一个”的性质。由此可知，本题可以设法使用分组背包来做。我们根据题目特性，巧用预处理把问题转化为分组背包问题。</p><span id="more"></span><p>首先进行预处理，我们用一个结构体来存储物品的信息，把所有物品依照主附件关系分为若干组用vector容器v构建二维数组来存储。</p><p>在读入数据时，如果第i件物品是主件，那我们就把第i件物品的价格（DP时用到）和价格与重要度的乘积（更新答案时用到，以下都称“实际权重”）push_back到v[i]中；如果第i件物品是第j件物品的附件，那就把物品j按照如下规定的思路push_back到v[j]，v[i]留空即可。</p><p>根据四种互斥情况，我们规定每组物品：</p><ul><li>第一个物品的价格和实际权重等于主件；</li><li>第二个物品的价格和实际权重等于主件+第一个附件；</li><li>第三个物品的价格和实际权重等于主件+第二个附件；</li><li>第四个物品的价格和实际权重等于主件+第一个附件+第二个附件；</li></ul><p>又因为主件=第一个物品，主件+第一个附件=第二个物品，故上述规定可以表示为：</p><ul><li>第一个物品的价格和实际权重等于主件；</li><li>第二个物品的价格和实际权重等于第一个物品+第一个附件；</li><li>第三个物品的价格和实际权重等于第一个物品+第二个附件；</li><li>第四个物品的价格和实际权重等于第二个物品+第二个附件；</li></ul><p>上述规定可以用一个for循环进行递推计算，每次加入新附件时在遍历已有该附件对应主件和该主件其它附件的同时进行累加，将累加后的结果push_back到末端即可。（具体请参照代码）</p><p>至此，预处理结束，设m件物品中有a件主件和m-a件附件，则这些物品已经被分为a组，每组物品以主件开头，最多4件物品（根据题目数据，附件是一定出现在主件之后的）。</p><p>问题已经彻底转化成了一个分组背包问题，直接套用分组背包DP的模板求解即可。</p><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">good</span>&#123;</span><span class="keyword">int</span> w,t;&#125;;</span><br><span class="line">vector&lt;good&gt; v[<span class="number">61</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,a,b,c,f[<span class="number">32001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&gt;y?x:y;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">      <span class="keyword">int</span> temp=v[c].<span class="built_in">size</span>();<span class="comment">//提前记录当前主件和该主件已出现的附件的总数，避免后面出现死循环</span></span><br><span class="line">      <span class="keyword">if</span>(!c)v[i].<span class="built_in">push_back</span>(&#123;a,a*b&#125;);<span class="comment">//处理主件</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;temp;k++)</span><br><span class="line">         v[c].<span class="built_in">push_back</span>(&#123;a+v[c][k].w,a*b+v[c][k].t&#125;);<span class="comment">//依据题解中规则处理附件</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//一维分组背包模板</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=n;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;v[i].<span class="built_in">size</span>();k++)</span><br><span class="line">    &#123;</span><br><span class="line">      good now=v[i][k];</span><br><span class="line">      <span class="keyword">if</span>(j&gt;=now.w)f[j]=<span class="built_in">max</span>(f[j],f[j-now.w]+now.t);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[n]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> OI/ACM </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P2296 寻找道路 题解</title>
      <link href="/2019/09/26/luogu-p2296/"/>
      <url>/2019/09/26/luogu-p2296/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/posts/luogu/banner.png" alt="banner"></p><h2 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h2><p><a href="https://www.luogu.com.cn/problem/P2296">https://www.luogu.com.cn/problem/P2296</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>读入图时建立正向边和反向边，两次DFS标记所有合法的点，再进行一遍BFS求最短路径。</p><span id="more"></span><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10001</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m,t1,t2,s,t,d[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N],go1[N],go2[N],go[N],inq[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; gt[N],g[N];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vis[x]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;gt[x].<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> to=gt[x][i];</span><br><span class="line">      <span class="keyword">if</span>(go1[x])go1[to]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(vis[to])<span class="keyword">continue</span>;</span><br><span class="line">      <span class="built_in">dfs1</span>(to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  vis[x]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g[x].<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> to=g[x][i];</span><br><span class="line">      <span class="keyword">if</span>(go2[x])go2[to]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span>(vis[to])<span class="keyword">continue</span>;</span><br><span class="line">      <span class="built_in">dfs2</span>(to);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;t1,&amp;t2);</span><br><span class="line">      <span class="keyword">if</span>(t1==t2)<span class="keyword">continue</span>;</span><br><span class="line">      gt[t2].<span class="built_in">push_back</span>(t1);<span class="comment">//反向建图</span></span><br><span class="line">      g[t1].<span class="built_in">push_back</span>(t2);<span class="comment">//正向建图</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;s,&amp;t);</span><br><span class="line">  go1[t]=go2[t]=<span class="number">1</span>;</span><br><span class="line">  d[t]=<span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">dfs1</span>(t);<span class="comment">//dfs反向图，标记和终点反向联通的点</span></span><br><span class="line">  <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(vis));</span><br><span class="line">  <span class="built_in">dfs2</span>(t);<span class="comment">//dfs正向图，标记和终点正向联通的点</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//标记所有合法点</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(!go1[i]&amp;&amp;!go2[i])<span class="keyword">continue</span>;</span><br><span class="line">      go[i]=<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;g[i].<span class="built_in">size</span>();j++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> to=g[i][j];</span><br><span class="line">      <span class="keyword">if</span>(!go1[to]&amp;&amp;!go2[to])</span><br><span class="line">        &#123;</span><br><span class="line">          go[i]=<span class="number">0</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  q.<span class="built_in">push</span>(s);</span><br><span class="line">  inq[s]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())<span class="comment">//bfs正向图，得最短路径</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> now=q.<span class="built_in">front</span>();</span><br><span class="line">      q.<span class="built_in">pop</span>();</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;g[now].<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">int</span> to=g[now][i];</span><br><span class="line">      <span class="keyword">if</span>(inq[to]||!go[to])<span class="keyword">continue</span>;</span><br><span class="line">      q.<span class="built_in">push</span>(to);</span><br><span class="line">      inq[to]=<span class="number">1</span>;</span><br><span class="line">      d[to]=d[now]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,d[t]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;     </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洛谷 </tag>
            
            <tag> OI/ACM </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 广度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P1010 幂次方 题解</title>
      <link href="/2019/05/08/luogu-p1010/"/>
      <url>/2019/05/08/luogu-p1010/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/posts/luogu/banner.png" alt="banner"></p><h2 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h2><p><a href="https://www.luogu.com.cn/problem/P1010">https://www.luogu.com.cn/problem/P1010</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>本蒟蒻来发一波题解，没多少技巧，就是打表。</p><span id="more"></span><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> for(i,a,b) for(int i=a;i&lt;=b;i++)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,mega[<span class="number">111</span>];<span class="comment">//mega数组存储预处理的2的1到14次方（2^15&gt;20000，所以之后的枚举只需到14即可）</span></span><br><span class="line">string open[<span class="number">15</span>];</span><br><span class="line"><span class="keyword">bool</span> odd;<span class="comment">//数的奇偶</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">even</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">    odd=<span class="number">1</span>;</span><br><span class="line">    n-=<span class="number">1</span>;<span class="comment">//如果是奇数就直接先-1变成偶数，最后再把1补上</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">even</span>();<span class="comment">//判断奇偶</span></span><br><span class="line">    <span class="keyword">for</span>(i,<span class="number">1</span>,<span class="number">14</span>)mega[i]=<span class="built_in">pow</span>(<span class="number">2</span>,i);<span class="comment">//预处理并存储2的1~14次方</span></span><br><span class="line"><span class="comment">//前方高能，预处理并存储1~14拆分后的字符串，后面用</span></span><br><span class="line">    open[<span class="number">1</span>]=<span class="string">&quot;2(0)&quot;</span>;open[<span class="number">2</span>]=<span class="string">&quot;2&quot;</span>;open[<span class="number">3</span>]=<span class="string">&quot;2+2(0)&quot;</span>;open[<span class="number">4</span>]=<span class="string">&quot;2(2)&quot;</span>;</span><br><span class="line">    open[<span class="number">5</span>]=<span class="string">&quot;2(2)+2(0)&quot;</span>;open[<span class="number">6</span>]=<span class="string">&quot;2(2)+2&quot;</span>;open[<span class="number">7</span>]=<span class="string">&quot;2(2)+2+2(0)&quot;</span>;</span><br><span class="line">    open[<span class="number">8</span>]=<span class="string">&quot;2(2+2(0))&quot;</span>;open[<span class="number">9</span>]=<span class="string">&quot;2(2+2(0))+2(0)&quot;</span>;open[<span class="number">10</span>]=<span class="string">&quot;2(2+2(0))+2&quot;</span>;</span><br><span class="line">    open[<span class="number">11</span>]=<span class="string">&quot;2(2+2(0))+2+2(0)&quot;</span>;open[<span class="number">12</span>]=<span class="string">&quot;2(2+2(0))+2(2)&quot;</span>;</span><br><span class="line">    open[<span class="number">13</span>]=<span class="string">&quot;2(2+2(0))+2(2)+2(0)&quot;</span>;open[<span class="number">14</span>]=<span class="string">&quot;2(2+2(0))+2(2)+2&quot;</span>;</span><br><span class="line"><span class="comment">//前方高能，逐一枚举，七层循环最多支持拆分成8项（奇数拆分后末尾的2（0）单独特判）</span></span><br><span class="line">    <span class="keyword">for</span>(x,<span class="number">0</span>,<span class="number">14</span>)</span><br><span class="line">    <span class="keyword">for</span>(y,x,<span class="number">14</span>)</span><br><span class="line">    <span class="keyword">for</span>(z,y,<span class="number">14</span>)</span><br><span class="line">    <span class="keyword">for</span>(i,z,<span class="number">14</span>)</span><br><span class="line">    <span class="keyword">for</span>(j,i,<span class="number">14</span>)</span><br><span class="line">    <span class="keyword">for</span>(k,j,<span class="number">14</span>)</span><br><span class="line">    <span class="keyword">for</span>(l,k,<span class="number">14</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(mega[i]+mega[j]+mega[k]+mega[l]+mega[x]+mega[y]+mega[z]==n)<span class="comment">//如果满足条件就输出</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(l&amp;&amp;l!=<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;2(&quot;</span>&lt;&lt;open[l]&lt;&lt;<span class="string">&#x27;)&#x27;</span>;<span class="comment">//特判，此项是0就不输出，是2的1次方就直接输出2，否则输出2（x），x也要拆，此时数据范围已经缩小到1~14，直接调用open数组然后输出即可</span></span><br><span class="line">            <span class="keyword">if</span>(l==<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;+2&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(k&amp;&amp;k!=<span class="number">1</span>)cout&lt;&lt;<span class="string">&#x27;+&#x27;</span>&lt;&lt;<span class="string">&quot;2(&quot;</span>&lt;&lt;open[k]&lt;&lt;<span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;+2&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(j&amp;&amp;j!=<span class="number">1</span>)cout&lt;&lt;<span class="string">&#x27;+&#x27;</span>&lt;&lt;<span class="string">&quot;2(&quot;</span>&lt;&lt;open[j]&lt;&lt;<span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(j==<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;+2&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&amp;&amp;i!=<span class="number">1</span>)cout&lt;&lt;<span class="string">&#x27;+&#x27;</span>&lt;&lt;<span class="string">&quot;2(&quot;</span>&lt;&lt;open[i]&lt;&lt;<span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;+2&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(z&amp;&amp;z!=<span class="number">1</span>)cout&lt;&lt;<span class="string">&#x27;+&#x27;</span>&lt;&lt;<span class="string">&quot;2(&quot;</span>&lt;&lt;open[z]&lt;&lt;<span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(z==<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;+2&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(y&amp;&amp;y!=<span class="number">1</span>)cout&lt;&lt;<span class="string">&#x27;+&#x27;</span>&lt;&lt;<span class="string">&quot;2(&quot;</span>&lt;&lt;open[y]&lt;&lt;<span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(y==<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;+2&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(x&amp;&amp;x!=<span class="number">1</span>)cout&lt;&lt;<span class="string">&#x27;+&#x27;</span>&lt;&lt;<span class="string">&quot;2(&quot;</span>&lt;&lt;open[x]&lt;&lt;<span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(x==<span class="number">1</span>)cout&lt;&lt;<span class="string">&quot;+2&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span>(odd)cout&lt;&lt;<span class="string">&quot;+2(0)&quot;</span>;<span class="comment">//奇数的话，把末尾1补上</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//找到一组就直接输出然后return0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 打表 </tag>
            
            <tag> 数论 </tag>
            
            <tag> 洛谷 </tag>
            
            <tag> OI/ACM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu P1603 斯诺登的密码 题解</title>
      <link href="/2019/04/19/luogu-p1603/"/>
      <url>/2019/04/19/luogu-p1603/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/posts/luogu/banner.png" alt="banner"></p><h2 id="原题链接"><a href="#原题链接" class="headerlink" title="原题链接"></a>原题链接</h2><p><a href="https://www.luogu.com.cn/problem/P1603">https://www.luogu.com.cn/problem/P1603</a></p><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这道题，我的思路有打表的成分，还用了哈希。</p><span id="more"></span><h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string s;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1111</span>],sx[<span class="number">1111</span>],h[<span class="number">55</span>],cnt,temp,start;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(string x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> b=<span class="number">1111111111</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> lens=x.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;lens;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans*=b;</span><br><span class="line">        ans+=x[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//打表，存储1~20的哈希值（first、another什么的另外存）</span></span><br><span class="line">    h[<span class="number">1</span>]=<span class="built_in">hash</span>(<span class="string">&quot;one&quot;</span>);</span><br><span class="line">    h[<span class="number">2</span>]=<span class="built_in">hash</span>(<span class="string">&quot;two&quot;</span>);</span><br><span class="line">    h[<span class="number">3</span>]=<span class="built_in">hash</span>(<span class="string">&quot;three&quot;</span>);</span><br><span class="line">    h[<span class="number">4</span>]=<span class="built_in">hash</span>(<span class="string">&quot;four&quot;</span>);</span><br><span class="line">    h[<span class="number">5</span>]=<span class="built_in">hash</span>(<span class="string">&quot;five&quot;</span>);</span><br><span class="line">    h[<span class="number">6</span>]=<span class="built_in">hash</span>(<span class="string">&quot;six&quot;</span>);</span><br><span class="line">    h[<span class="number">7</span>]=<span class="built_in">hash</span>(<span class="string">&quot;seven&quot;</span>);</span><br><span class="line">    h[<span class="number">8</span>]=<span class="built_in">hash</span>(<span class="string">&quot;eight&quot;</span>);</span><br><span class="line">    h[<span class="number">9</span>]=<span class="built_in">hash</span>(<span class="string">&quot;nine&quot;</span>);</span><br><span class="line">    h[<span class="number">10</span>]=<span class="built_in">hash</span>(<span class="string">&quot;ten&quot;</span>);</span><br><span class="line">    h[<span class="number">11</span>]=<span class="built_in">hash</span>(<span class="string">&quot;eleven&quot;</span>);</span><br><span class="line">    h[<span class="number">12</span>]=<span class="built_in">hash</span>(<span class="string">&quot;twelve&quot;</span>);</span><br><span class="line">    h[<span class="number">13</span>]=<span class="built_in">hash</span>(<span class="string">&quot;thirteen&quot;</span>);</span><br><span class="line">    h[<span class="number">14</span>]=<span class="built_in">hash</span>(<span class="string">&quot;fourteen&quot;</span>);</span><br><span class="line">    h[<span class="number">15</span>]=<span class="built_in">hash</span>(<span class="string">&quot;fifteen&quot;</span>);</span><br><span class="line">    h[<span class="number">16</span>]=<span class="built_in">hash</span>(<span class="string">&quot;sixteen&quot;</span>);</span><br><span class="line">    h[<span class="number">17</span>]=<span class="built_in">hash</span>(<span class="string">&quot;seventeen&quot;</span>);</span><br><span class="line">    h[<span class="number">18</span>]=<span class="built_in">hash</span>(<span class="string">&quot;eighteen&quot;</span>);</span><br><span class="line">    h[<span class="number">19</span>]=<span class="built_in">hash</span>(<span class="string">&quot;nineteen&quot;</span>);</span><br><span class="line">    h[<span class="number">20</span>]=<span class="built_in">hash</span>(<span class="string">&quot;twenty&quot;</span>);</span><br><span class="line">    h[<span class="number">21</span>]=<span class="built_in">hash</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    h[<span class="number">22</span>]=<span class="built_in">hash</span>(<span class="string">&quot;both&quot;</span>);</span><br><span class="line">    h[<span class="number">23</span>]=<span class="built_in">hash</span>(<span class="string">&quot;first&quot;</span>);</span><br><span class="line">    h[<span class="number">24</span>]=<span class="built_in">hash</span>(<span class="string">&quot;second&quot;</span>);</span><br><span class="line">    h[<span class="number">25</span>]=<span class="built_in">hash</span>(<span class="string">&quot;third&quot;</span>);</span><br><span class="line">    h[<span class="number">26</span>]=<span class="built_in">hash</span>(<span class="string">&quot;another&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;s;</span><br><span class="line">        <span class="keyword">if</span>(s[<span class="number">0</span>]&lt;<span class="string">&#x27;a&#x27;</span>)s[<span class="number">0</span>]+=<span class="number">32</span>;<span class="comment">//单词首字母统一转换成小写</span></span><br><span class="line">        temp=<span class="built_in">hash</span>(s);<span class="comment">//计算该单词哈希值，之后逐一比对(提前计算好各数字平方%100之后的数)</span></span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">1</span>]||temp==h[<span class="number">21</span>]||temp==h[<span class="number">23</span>]||temp==h[<span class="number">26</span>])a[i]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">2</span>]||temp==h[<span class="number">22</span>]||temp==h[<span class="number">24</span>])a[i]=<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">3</span>]||temp==h[<span class="number">25</span>])a[i]=<span class="number">9</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">4</span>])a[i]=<span class="number">16</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">5</span>]||temp==h[<span class="number">15</span>])a[i]=<span class="number">25</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">6</span>])a[i]=<span class="number">36</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">7</span>])a[i]=<span class="number">49</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">8</span>])a[i]=<span class="number">64</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">9</span>])a[i]=<span class="number">81</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">10</span>]||temp==h[<span class="number">20</span>])a[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">11</span>])a[i]=<span class="number">21</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">12</span>])a[i]=<span class="number">44</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">13</span>])a[i]=<span class="number">69</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">14</span>])a[i]=<span class="number">96</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">16</span>])a[i]=<span class="number">56</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">17</span>])a[i]=<span class="number">89</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">18</span>])a[i]=<span class="number">24</span>;</span><br><span class="line">        <span class="keyword">if</span>(temp==h[<span class="number">19</span>])a[i]=<span class="number">61</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;s;<span class="comment">//输入末尾的句点，没卵用</span></span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">7</span>);<span class="comment">//将数字从小到大排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sx[++cnt]=a[i]/<span class="number">10</span>;</span><br><span class="line">        sx[++cnt]=a[i]%<span class="number">10</span>;</span><br><span class="line">    &#125;<span class="comment">//此处可能比较笨，是逐位输入到另一个数组</span></span><br><span class="line">    <span class="keyword">while</span>(sx[start]==<span class="number">0</span>&amp;&amp;start&lt;cnt)start++;<span class="comment">//滤掉开头所有0（如果全都是0则保留一个）</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=cnt;i++)cout&lt;&lt;sx[i];<span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 打表 </tag>
            
            <tag> 洛谷 </tag>
            
            <tag> OI/ACM </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
